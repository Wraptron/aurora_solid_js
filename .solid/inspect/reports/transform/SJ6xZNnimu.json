{
  "resolvedId": "C:/solid js/authentication-client/node_modules/@solidjs/router/dist/routing.js?v=1b141ace",
  "transforms": [
    {
      "name": "__load__",
      "result": "import { createComponent, createContext, createMemo, createRenderEffect, createSignal, on, onCleanup, untrack, useContext, startTransition, resetErrorBoundaries } from \"solid-js\";\r\nimport { isServer, delegateEvents } from \"solid-js/web\";\r\nimport { normalizeIntegration } from \"./integration\";\r\nimport { createBeforeLeave } from \"./lifecycle\";\r\nimport { createMemoObject, extractSearchParams, invariant, resolvePath, createMatcher, joinPaths, scoreRoute, mergeSearchString, expandOptionals } from \"./utils\";\r\nconst MAX_REDIRECTS = 100;\r\nexport const RouterContextObj = createContext();\r\nexport const RouteContextObj = createContext();\r\nexport const useRouter = () => invariant(useContext(RouterContextObj), \"Make sure your app is wrapped in a <Router />\");\r\nlet TempRoute;\r\nexport const useRoute = () => TempRoute || useContext(RouteContextObj) || useRouter().base;\r\nexport const useResolvedPath = (path) => {\r\n    const route = useRoute();\r\n    return createMemo(() => route.resolvePath(path()));\r\n};\r\nexport const useHref = (to) => {\r\n    const router = useRouter();\r\n    return createMemo(() => {\r\n        const to_ = to();\r\n        return to_ !== undefined ? router.renderPath(to_) : to_;\r\n    });\r\n};\r\nexport const useNavigate = () => useRouter().navigatorFactory();\r\nexport const useLocation = () => useRouter().location;\r\nexport const useIsRouting = () => useRouter().isRouting;\r\nexport const useMatch = (path, matchFilters) => {\r\n    const location = useLocation();\r\n    const matchers = createMemo(() => expandOptionals(path()).map(path => createMatcher(path, undefined, matchFilters)));\r\n    return createMemo(() => {\r\n        for (const matcher of matchers()) {\r\n            const match = matcher(location.pathname);\r\n            if (match)\r\n                return match;\r\n        }\r\n    });\r\n};\r\nexport const useParams = () => useRoute().params;\r\nexport const useRouteData = () => useRoute().data;\r\nexport const useSearchParams = () => {\r\n    const location = useLocation();\r\n    const navigate = useNavigate();\r\n    const setSearchParams = (params, options) => {\r\n        const searchString = untrack(() => mergeSearchString(location.search, params));\r\n        navigate(location.pathname + searchString + location.hash, {\r\n            scroll: false,\r\n            resolve: false,\r\n            ...options\r\n        });\r\n    };\r\n    return [location.query, setSearchParams];\r\n};\r\nexport const useBeforeLeave = (listener) => {\r\n    const s = useRouter().beforeLeave.subscribe({\r\n        listener,\r\n        location: useLocation(),\r\n        navigate: useNavigate()\r\n    });\r\n    onCleanup(s);\r\n};\r\nexport function createRoutes(routeDef, base = \"\", fallback) {\r\n    const { component, data, children } = routeDef;\r\n    const isLeaf = !children || (Array.isArray(children) && !children.length);\r\n    const shared = {\r\n        key: routeDef,\r\n        element: component\r\n            ? () => createComponent(component, {})\r\n            : () => {\r\n                const { element } = routeDef;\r\n                return element === undefined && fallback\r\n                    ? createComponent(fallback, {})\r\n                    : element;\r\n            },\r\n        preload: routeDef.component\r\n            ? component.preload\r\n            : routeDef.preload,\r\n        data\r\n    };\r\n    return asArray(routeDef.path).reduce((acc, path) => {\r\n        for (const originalPath of expandOptionals(path)) {\r\n            const path = joinPaths(base, originalPath);\r\n            const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\r\n            acc.push({\r\n                ...shared,\r\n                originalPath,\r\n                pattern,\r\n                matcher: createMatcher(pattern, !isLeaf, routeDef.matchFilters)\r\n            });\r\n        }\r\n        return acc;\r\n    }, []);\r\n}\r\nexport function createBranch(routes, index = 0) {\r\n    return {\r\n        routes,\r\n        score: scoreRoute(routes[routes.length - 1]) * 10000 - index,\r\n        matcher(location) {\r\n            const matches = [];\r\n            for (let i = routes.length - 1; i >= 0; i--) {\r\n                const route = routes[i];\r\n                const match = route.matcher(location);\r\n                if (!match) {\r\n                    return null;\r\n                }\r\n                matches.unshift({\r\n                    ...match,\r\n                    route\r\n                });\r\n            }\r\n            return matches;\r\n        }\r\n    };\r\n}\r\nfunction asArray(value) {\r\n    return Array.isArray(value) ? value : [value];\r\n}\r\nexport function createBranches(routeDef, base = \"\", fallback, stack = [], branches = []) {\r\n    const routeDefs = asArray(routeDef);\r\n    for (let i = 0, len = routeDefs.length; i < len; i++) {\r\n        const def = routeDefs[i];\r\n        if (def && typeof def === \"object\" && def.hasOwnProperty(\"path\")) {\r\n            const routes = createRoutes(def, base, fallback);\r\n            for (const route of routes) {\r\n                stack.push(route);\r\n                const isEmptyArray = Array.isArray(def.children) && def.children.length === 0;\r\n                if (def.children && !isEmptyArray) {\r\n                    createBranches(def.children, route.pattern, fallback, stack, branches);\r\n                }\r\n                else {\r\n                    const branch = createBranch([...stack], branches.length);\r\n                    branches.push(branch);\r\n                }\r\n                stack.pop();\r\n            }\r\n        }\r\n    }\r\n    // Stack will be empty on final return\r\n    return stack.length ? branches : branches.sort((a, b) => b.score - a.score);\r\n}\r\nexport function getRouteMatches(branches, location) {\r\n    for (let i = 0, len = branches.length; i < len; i++) {\r\n        const match = branches[i].matcher(location);\r\n        if (match) {\r\n            return match;\r\n        }\r\n    }\r\n    return [];\r\n}\r\nexport function createLocation(path, state) {\r\n    const origin = new URL(\"http://sar\");\r\n    const url = createMemo(prev => {\r\n        const path_ = path();\r\n        try {\r\n            return new URL(path_, origin);\r\n        }\r\n        catch (err) {\r\n            console.error(`Invalid path ${path_}`);\r\n            return prev;\r\n        }\r\n    }, origin, {\r\n        equals: (a, b) => a.href === b.href\r\n    });\r\n    const pathname = createMemo(() => url().pathname);\r\n    const search = createMemo(() => url().search, true);\r\n    const hash = createMemo(() => url().hash);\r\n    const key = createMemo(() => \"\");\r\n    return {\r\n        get pathname() {\r\n            return pathname();\r\n        },\r\n        get search() {\r\n            return search();\r\n        },\r\n        get hash() {\r\n            return hash();\r\n        },\r\n        get state() {\r\n            return state();\r\n        },\r\n        get key() {\r\n            return key();\r\n        },\r\n        query: createMemoObject(on(search, () => extractSearchParams(url())))\r\n    };\r\n}\r\nexport function createRouterContext(integration, base = \"\", data, out) {\r\n    const { signal: [source, setSource], utils = {} } = normalizeIntegration(integration);\r\n    const parsePath = utils.parsePath || (p => p);\r\n    const renderPath = utils.renderPath || (p => p);\r\n    const beforeLeave = utils.beforeLeave || createBeforeLeave();\r\n    const basePath = resolvePath(\"\", base);\r\n    const output = isServer && out\r\n        ? Object.assign(out, {\r\n            matches: [],\r\n            url: undefined\r\n        })\r\n        : undefined;\r\n    if (basePath === undefined) {\r\n        throw new Error(`${basePath} is not a valid base path`);\r\n    }\r\n    else if (basePath && !source().value) {\r\n        setSource({ value: basePath, replace: true, scroll: false });\r\n    }\r\n    const [isRouting, setIsRouting] = createSignal(false);\r\n    const start = async (callback) => {\r\n        setIsRouting(true);\r\n        try {\r\n            await startTransition(callback);\r\n        }\r\n        finally {\r\n            setIsRouting(false);\r\n        }\r\n    };\r\n    const [reference, setReference] = createSignal(source().value);\r\n    const [state, setState] = createSignal(source().state);\r\n    const location = createLocation(reference, state);\r\n    const referrers = [];\r\n    const baseRoute = {\r\n        pattern: basePath,\r\n        params: {},\r\n        path: () => basePath,\r\n        outlet: () => null,\r\n        resolvePath(to) {\r\n            return resolvePath(basePath, to);\r\n        }\r\n    };\r\n    if (data) {\r\n        try {\r\n            TempRoute = baseRoute;\r\n            baseRoute.data = data({\r\n                data: undefined,\r\n                params: {},\r\n                location,\r\n                navigate: navigatorFactory(baseRoute)\r\n            });\r\n        }\r\n        finally {\r\n            TempRoute = undefined;\r\n        }\r\n    }\r\n    function navigateFromRoute(route, to, options) {\r\n        // Untrack in case someone navigates in an effect - don't want to track `reference` or route paths\r\n        untrack(() => {\r\n            if (typeof to === \"number\") {\r\n                if (!to) {\r\n                    // A delta of 0 means stay at the current location, so it is ignored\r\n                }\r\n                else if (utils.go) {\r\n                    beforeLeave.confirm(to, options) && utils.go(to);\r\n                }\r\n                else {\r\n                    console.warn(\"Router integration does not support relative routing\");\r\n                }\r\n                return;\r\n            }\r\n            const { replace, resolve, scroll, state: nextState } = {\r\n                replace: false,\r\n                resolve: true,\r\n                scroll: true,\r\n                ...options\r\n            };\r\n            const resolvedTo = resolve ? route.resolvePath(to) : resolvePath(\"\", to);\r\n            if (resolvedTo === undefined) {\r\n                throw new Error(`Path '${to}' is not a routable path`);\r\n            }\r\n            else if (referrers.length >= MAX_REDIRECTS) {\r\n                throw new Error(\"Too many redirects\");\r\n            }\r\n            const current = reference();\r\n            if (resolvedTo !== current || nextState !== state()) {\r\n                if (isServer) {\r\n                    if (output) {\r\n                        output.url = resolvedTo;\r\n                    }\r\n                    setSource({ value: resolvedTo, replace, scroll, state: nextState });\r\n                }\r\n                else if (beforeLeave.confirm(resolvedTo, options)) {\r\n                    const len = referrers.push({ value: current, replace, scroll, state: state() });\r\n                    start(() => {\r\n                        setReference(resolvedTo);\r\n                        setState(nextState);\r\n                        resetErrorBoundaries();\r\n                    }).then(() => {\r\n                        if (referrers.length === len) {\r\n                            navigateEnd({\r\n                                value: resolvedTo,\r\n                                state: nextState\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    }\r\n    function navigatorFactory(route) {\r\n        // Workaround for vite issue (https://github.com/vitejs/vite/issues/3803)\r\n        route = route || useContext(RouteContextObj) || baseRoute;\r\n        return (to, options) => navigateFromRoute(route, to, options);\r\n    }\r\n    function navigateEnd(next) {\r\n        const first = referrers[0];\r\n        if (first) {\r\n            if (next.value !== first.value || next.state !== first.state) {\r\n                setSource({\r\n                    ...next,\r\n                    replace: first.replace,\r\n                    scroll: first.scroll\r\n                });\r\n            }\r\n            referrers.length = 0;\r\n        }\r\n    }\r\n    createRenderEffect(() => {\r\n        const { value, state } = source();\r\n        // Untrack this whole block so `start` doesn't cause Solid's Listener to be preserved\r\n        untrack(() => {\r\n            if (value !== reference()) {\r\n                start(() => {\r\n                    setReference(value);\r\n                    setState(state);\r\n                });\r\n            }\r\n        });\r\n    });\r\n    if (!isServer) {\r\n        function handleAnchorClick(evt) {\r\n            if (evt.defaultPrevented ||\r\n                evt.button !== 0 ||\r\n                evt.metaKey ||\r\n                evt.altKey ||\r\n                evt.ctrlKey ||\r\n                evt.shiftKey)\r\n                return;\r\n            const a = evt\r\n                .composedPath()\r\n                .find(el => el instanceof Node && el.nodeName.toUpperCase() === \"A\");\r\n            if (!a || !a.hasAttribute(\"link\"))\r\n                return;\r\n            const href = a.href;\r\n            if (a.target || (!href && !a.hasAttribute(\"state\")))\r\n                return;\r\n            const rel = (a.getAttribute(\"rel\") || \"\").split(/\\s+/);\r\n            if (a.hasAttribute(\"download\") || (rel && rel.includes(\"external\")))\r\n                return;\r\n            const url = new URL(href);\r\n            if (url.origin !== window.location.origin ||\r\n                (basePath && url.pathname && !url.pathname.toLowerCase().startsWith(basePath.toLowerCase())))\r\n                return;\r\n            const to = parsePath(url.pathname + url.search + url.hash);\r\n            const state = a.getAttribute(\"state\");\r\n            evt.preventDefault();\r\n            navigateFromRoute(baseRoute, to, {\r\n                resolve: false,\r\n                replace: a.hasAttribute(\"replace\"),\r\n                scroll: !a.hasAttribute(\"noscroll\"),\r\n                state: state && JSON.parse(state)\r\n            });\r\n        }\r\n        // ensure delegated events run first\r\n        delegateEvents([\"click\"]);\r\n        document.addEventListener(\"click\", handleAnchorClick);\r\n        onCleanup(() => document.removeEventListener(\"click\", handleAnchorClick));\r\n    }\r\n    return {\r\n        base: baseRoute,\r\n        out: output,\r\n        location,\r\n        isRouting,\r\n        renderPath,\r\n        parsePath,\r\n        navigatorFactory,\r\n        beforeLeave\r\n    };\r\n}\r\nexport function createRouteContext(router, parent, child, match, params) {\r\n    const { base, location, navigatorFactory } = router;\r\n    const { pattern, element: outlet, preload, data } = match().route;\r\n    const path = createMemo(() => match().path);\r\n    preload && preload();\r\n    const route = {\r\n        parent,\r\n        pattern,\r\n        get child() {\r\n            return child();\r\n        },\r\n        path,\r\n        params,\r\n        data: parent.data,\r\n        outlet,\r\n        resolvePath(to) {\r\n            return resolvePath(base.path(), to, path());\r\n        }\r\n    };\r\n    if (data) {\r\n        try {\r\n            TempRoute = route;\r\n            route.data = data({ data: parent.data, params, location, navigate: navigatorFactory(route) });\r\n        }\r\n        finally {\r\n            TempRoute = undefined;\r\n        }\r\n    }\r\n    return route;\r\n}\r\n",
      "start": 1691669611685,
      "end": 1691669611685
    },
    {
      "name": "vite:import-analysis",
      "result": "import { createComponent, createContext, createMemo, createRenderEffect, createSignal, on, onCleanup, untrack, useContext, startTransition, resetErrorBoundaries } from \"/node_modules/.vite/deps/solid-js.js?v=1b141ace\";\r\nimport { isServer, delegateEvents } from \"/node_modules/.vite/deps/solid-js_web.js?v=1b141ace\";\r\nimport { normalizeIntegration } from \"/node_modules/@solidjs/router/dist/integration.js?v=1b141ace\";\r\nimport { createBeforeLeave } from \"/node_modules/@solidjs/router/dist/lifecycle.js?v=1b141ace\";\r\nimport { createMemoObject, extractSearchParams, invariant, resolvePath, createMatcher, joinPaths, scoreRoute, mergeSearchString, expandOptionals } from \"/node_modules/@solidjs/router/dist/utils.js?v=1b141ace\";\r\nconst MAX_REDIRECTS = 100;\r\nexport const RouterContextObj = createContext();\r\nexport const RouteContextObj = createContext();\r\nexport const useRouter = () => invariant(useContext(RouterContextObj), \"Make sure your app is wrapped in a <Router />\");\r\nlet TempRoute;\r\nexport const useRoute = () => TempRoute || useContext(RouteContextObj) || useRouter().base;\r\nexport const useResolvedPath = (path) => {\r\n    const route = useRoute();\r\n    return createMemo(() => route.resolvePath(path()));\r\n};\r\nexport const useHref = (to) => {\r\n    const router = useRouter();\r\n    return createMemo(() => {\r\n        const to_ = to();\r\n        return to_ !== undefined ? router.renderPath(to_) : to_;\r\n    });\r\n};\r\nexport const useNavigate = () => useRouter().navigatorFactory();\r\nexport const useLocation = () => useRouter().location;\r\nexport const useIsRouting = () => useRouter().isRouting;\r\nexport const useMatch = (path, matchFilters) => {\r\n    const location = useLocation();\r\n    const matchers = createMemo(() => expandOptionals(path()).map(path => createMatcher(path, undefined, matchFilters)));\r\n    return createMemo(() => {\r\n        for (const matcher of matchers()) {\r\n            const match = matcher(location.pathname);\r\n            if (match)\r\n                return match;\r\n        }\r\n    });\r\n};\r\nexport const useParams = () => useRoute().params;\r\nexport const useRouteData = () => useRoute().data;\r\nexport const useSearchParams = () => {\r\n    const location = useLocation();\r\n    const navigate = useNavigate();\r\n    const setSearchParams = (params, options) => {\r\n        const searchString = untrack(() => mergeSearchString(location.search, params));\r\n        navigate(location.pathname + searchString + location.hash, {\r\n            scroll: false,\r\n            resolve: false,\r\n            ...options\r\n        });\r\n    };\r\n    return [location.query, setSearchParams];\r\n};\r\nexport const useBeforeLeave = (listener) => {\r\n    const s = useRouter().beforeLeave.subscribe({\r\n        listener,\r\n        location: useLocation(),\r\n        navigate: useNavigate()\r\n    });\r\n    onCleanup(s);\r\n};\r\nexport function createRoutes(routeDef, base = \"\", fallback) {\r\n    const { component, data, children } = routeDef;\r\n    const isLeaf = !children || (Array.isArray(children) && !children.length);\r\n    const shared = {\r\n        key: routeDef,\r\n        element: component\r\n            ? () => createComponent(component, {})\r\n            : () => {\r\n                const { element } = routeDef;\r\n                return element === undefined && fallback\r\n                    ? createComponent(fallback, {})\r\n                    : element;\r\n            },\r\n        preload: routeDef.component\r\n            ? component.preload\r\n            : routeDef.preload,\r\n        data\r\n    };\r\n    return asArray(routeDef.path).reduce((acc, path) => {\r\n        for (const originalPath of expandOptionals(path)) {\r\n            const path = joinPaths(base, originalPath);\r\n            const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\r\n            acc.push({\r\n                ...shared,\r\n                originalPath,\r\n                pattern,\r\n                matcher: createMatcher(pattern, !isLeaf, routeDef.matchFilters)\r\n            });\r\n        }\r\n        return acc;\r\n    }, []);\r\n}\r\nexport function createBranch(routes, index = 0) {\r\n    return {\r\n        routes,\r\n        score: scoreRoute(routes[routes.length - 1]) * 10000 - index,\r\n        matcher(location) {\r\n            const matches = [];\r\n            for (let i = routes.length - 1; i >= 0; i--) {\r\n                const route = routes[i];\r\n                const match = route.matcher(location);\r\n                if (!match) {\r\n                    return null;\r\n                }\r\n                matches.unshift({\r\n                    ...match,\r\n                    route\r\n                });\r\n            }\r\n            return matches;\r\n        }\r\n    };\r\n}\r\nfunction asArray(value) {\r\n    return Array.isArray(value) ? value : [value];\r\n}\r\nexport function createBranches(routeDef, base = \"\", fallback, stack = [], branches = []) {\r\n    const routeDefs = asArray(routeDef);\r\n    for (let i = 0, len = routeDefs.length; i < len; i++) {\r\n        const def = routeDefs[i];\r\n        if (def && typeof def === \"object\" && def.hasOwnProperty(\"path\")) {\r\n            const routes = createRoutes(def, base, fallback);\r\n            for (const route of routes) {\r\n                stack.push(route);\r\n                const isEmptyArray = Array.isArray(def.children) && def.children.length === 0;\r\n                if (def.children && !isEmptyArray) {\r\n                    createBranches(def.children, route.pattern, fallback, stack, branches);\r\n                }\r\n                else {\r\n                    const branch = createBranch([...stack], branches.length);\r\n                    branches.push(branch);\r\n                }\r\n                stack.pop();\r\n            }\r\n        }\r\n    }\r\n    // Stack will be empty on final return\r\n    return stack.length ? branches : branches.sort((a, b) => b.score - a.score);\r\n}\r\nexport function getRouteMatches(branches, location) {\r\n    for (let i = 0, len = branches.length; i < len; i++) {\r\n        const match = branches[i].matcher(location);\r\n        if (match) {\r\n            return match;\r\n        }\r\n    }\r\n    return [];\r\n}\r\nexport function createLocation(path, state) {\r\n    const origin = new URL(\"http://sar\");\r\n    const url = createMemo(prev => {\r\n        const path_ = path();\r\n        try {\r\n            return new URL(path_, origin);\r\n        }\r\n        catch (err) {\r\n            console.error(`Invalid path ${path_}`);\r\n            return prev;\r\n        }\r\n    }, origin, {\r\n        equals: (a, b) => a.href === b.href\r\n    });\r\n    const pathname = createMemo(() => url().pathname);\r\n    const search = createMemo(() => url().search, true);\r\n    const hash = createMemo(() => url().hash);\r\n    const key = createMemo(() => \"\");\r\n    return {\r\n        get pathname() {\r\n            return pathname();\r\n        },\r\n        get search() {\r\n            return search();\r\n        },\r\n        get hash() {\r\n            return hash();\r\n        },\r\n        get state() {\r\n            return state();\r\n        },\r\n        get key() {\r\n            return key();\r\n        },\r\n        query: createMemoObject(on(search, () => extractSearchParams(url())))\r\n    };\r\n}\r\nexport function createRouterContext(integration, base = \"\", data, out) {\r\n    const { signal: [source, setSource], utils = {} } = normalizeIntegration(integration);\r\n    const parsePath = utils.parsePath || (p => p);\r\n    const renderPath = utils.renderPath || (p => p);\r\n    const beforeLeave = utils.beforeLeave || createBeforeLeave();\r\n    const basePath = resolvePath(\"\", base);\r\n    const output = isServer && out\r\n        ? Object.assign(out, {\r\n            matches: [],\r\n            url: undefined\r\n        })\r\n        : undefined;\r\n    if (basePath === undefined) {\r\n        throw new Error(`${basePath} is not a valid base path`);\r\n    }\r\n    else if (basePath && !source().value) {\r\n        setSource({ value: basePath, replace: true, scroll: false });\r\n    }\r\n    const [isRouting, setIsRouting] = createSignal(false);\r\n    const start = async (callback) => {\r\n        setIsRouting(true);\r\n        try {\r\n            await startTransition(callback);\r\n        }\r\n        finally {\r\n            setIsRouting(false);\r\n        }\r\n    };\r\n    const [reference, setReference] = createSignal(source().value);\r\n    const [state, setState] = createSignal(source().state);\r\n    const location = createLocation(reference, state);\r\n    const referrers = [];\r\n    const baseRoute = {\r\n        pattern: basePath,\r\n        params: {},\r\n        path: () => basePath,\r\n        outlet: () => null,\r\n        resolvePath(to) {\r\n            return resolvePath(basePath, to);\r\n        }\r\n    };\r\n    if (data) {\r\n        try {\r\n            TempRoute = baseRoute;\r\n            baseRoute.data = data({\r\n                data: undefined,\r\n                params: {},\r\n                location,\r\n                navigate: navigatorFactory(baseRoute)\r\n            });\r\n        }\r\n        finally {\r\n            TempRoute = undefined;\r\n        }\r\n    }\r\n    function navigateFromRoute(route, to, options) {\r\n        // Untrack in case someone navigates in an effect - don't want to track `reference` or route paths\r\n        untrack(() => {\r\n            if (typeof to === \"number\") {\r\n                if (!to) {\r\n                    // A delta of 0 means stay at the current location, so it is ignored\r\n                }\r\n                else if (utils.go) {\r\n                    beforeLeave.confirm(to, options) && utils.go(to);\r\n                }\r\n                else {\r\n                    console.warn(\"Router integration does not support relative routing\");\r\n                }\r\n                return;\r\n            }\r\n            const { replace, resolve, scroll, state: nextState } = {\r\n                replace: false,\r\n                resolve: true,\r\n                scroll: true,\r\n                ...options\r\n            };\r\n            const resolvedTo = resolve ? route.resolvePath(to) : resolvePath(\"\", to);\r\n            if (resolvedTo === undefined) {\r\n                throw new Error(`Path '${to}' is not a routable path`);\r\n            }\r\n            else if (referrers.length >= MAX_REDIRECTS) {\r\n                throw new Error(\"Too many redirects\");\r\n            }\r\n            const current = reference();\r\n            if (resolvedTo !== current || nextState !== state()) {\r\n                if (isServer) {\r\n                    if (output) {\r\n                        output.url = resolvedTo;\r\n                    }\r\n                    setSource({ value: resolvedTo, replace, scroll, state: nextState });\r\n                }\r\n                else if (beforeLeave.confirm(resolvedTo, options)) {\r\n                    const len = referrers.push({ value: current, replace, scroll, state: state() });\r\n                    start(() => {\r\n                        setReference(resolvedTo);\r\n                        setState(nextState);\r\n                        resetErrorBoundaries();\r\n                    }).then(() => {\r\n                        if (referrers.length === len) {\r\n                            navigateEnd({\r\n                                value: resolvedTo,\r\n                                state: nextState\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    }\r\n    function navigatorFactory(route) {\r\n        // Workaround for vite issue (https://github.com/vitejs/vite/issues/3803)\r\n        route = route || useContext(RouteContextObj) || baseRoute;\r\n        return (to, options) => navigateFromRoute(route, to, options);\r\n    }\r\n    function navigateEnd(next) {\r\n        const first = referrers[0];\r\n        if (first) {\r\n            if (next.value !== first.value || next.state !== first.state) {\r\n                setSource({\r\n                    ...next,\r\n                    replace: first.replace,\r\n                    scroll: first.scroll\r\n                });\r\n            }\r\n            referrers.length = 0;\r\n        }\r\n    }\r\n    createRenderEffect(() => {\r\n        const { value, state } = source();\r\n        // Untrack this whole block so `start` doesn't cause Solid's Listener to be preserved\r\n        untrack(() => {\r\n            if (value !== reference()) {\r\n                start(() => {\r\n                    setReference(value);\r\n                    setState(state);\r\n                });\r\n            }\r\n        });\r\n    });\r\n    if (!isServer) {\r\n        function handleAnchorClick(evt) {\r\n            if (evt.defaultPrevented ||\r\n                evt.button !== 0 ||\r\n                evt.metaKey ||\r\n                evt.altKey ||\r\n                evt.ctrlKey ||\r\n                evt.shiftKey)\r\n                return;\r\n            const a = evt\r\n                .composedPath()\r\n                .find(el => el instanceof Node && el.nodeName.toUpperCase() === \"A\");\r\n            if (!a || !a.hasAttribute(\"link\"))\r\n                return;\r\n            const href = a.href;\r\n            if (a.target || (!href && !a.hasAttribute(\"state\")))\r\n                return;\r\n            const rel = (a.getAttribute(\"rel\") || \"\").split(/\\s+/);\r\n            if (a.hasAttribute(\"download\") || (rel && rel.includes(\"external\")))\r\n                return;\r\n            const url = new URL(href);\r\n            if (url.origin !== window.location.origin ||\r\n                (basePath && url.pathname && !url.pathname.toLowerCase().startsWith(basePath.toLowerCase())))\r\n                return;\r\n            const to = parsePath(url.pathname + url.search + url.hash);\r\n            const state = a.getAttribute(\"state\");\r\n            evt.preventDefault();\r\n            navigateFromRoute(baseRoute, to, {\r\n                resolve: false,\r\n                replace: a.hasAttribute(\"replace\"),\r\n                scroll: !a.hasAttribute(\"noscroll\"),\r\n                state: state && JSON.parse(state)\r\n            });\r\n        }\r\n        // ensure delegated events run first\r\n        delegateEvents([\"click\"]);\r\n        document.addEventListener(\"click\", handleAnchorClick);\r\n        onCleanup(() => document.removeEventListener(\"click\", handleAnchorClick));\r\n    }\r\n    return {\r\n        base: baseRoute,\r\n        out: output,\r\n        location,\r\n        isRouting,\r\n        renderPath,\r\n        parsePath,\r\n        navigatorFactory,\r\n        beforeLeave\r\n    };\r\n}\r\nexport function createRouteContext(router, parent, child, match, params) {\r\n    const { base, location, navigatorFactory } = router;\r\n    const { pattern, element: outlet, preload, data } = match().route;\r\n    const path = createMemo(() => match().path);\r\n    preload && preload();\r\n    const route = {\r\n        parent,\r\n        pattern,\r\n        get child() {\r\n            return child();\r\n        },\r\n        path,\r\n        params,\r\n        data: parent.data,\r\n        outlet,\r\n        resolvePath(to) {\r\n            return resolvePath(base.path(), to, path());\r\n        }\r\n    };\r\n    if (data) {\r\n        try {\r\n            TempRoute = route;\r\n            route.data = data({ data: parent.data, params, location, navigate: navigatorFactory(route) });\r\n        }\r\n        finally {\r\n            TempRoute = undefined;\r\n        }\r\n    }\r\n    return route;\r\n}\r\n",
      "start": 1691669611685,
      "end": 1691669611687,
      "order": "normal"
    }
  ]
}
