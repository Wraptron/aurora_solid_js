{
  "resolvedId": "C:/solid js/authentication-client/node_modules/@solidjs/meta/dist/index.jsx?v=1b141ace",
  "transforms": [
    {
      "name": "__load__",
      "result": "import { createContext, createRenderEffect, createUniqueId, onCleanup, sharedConfig, useContext } from \"solid-js\";\r\nimport { isServer, spread, escape } from \"solid-js/web\";\r\nexport const MetaContext = createContext();\r\nconst cascadingTags = [\"title\", \"meta\"];\r\nconst getTagType = (tag) => tag.tag + (tag.name ? `.${tag.name}\"` : \"\");\r\nconst MetaProvider = props => {\r\n    if (!isServer && !sharedConfig.context) {\r\n        const ssrTags = document.head.querySelectorAll(`[data-sm]`);\r\n        // `forEach` on `NodeList` is not supported in Googlebot, so use a workaround\r\n        Array.prototype.forEach.call(ssrTags, (ssrTag) => ssrTag.parentNode.removeChild(ssrTag));\r\n    }\r\n    const cascadedTagInstances = new Map();\r\n    // TODO: use one element for all tags of the same type, just swap out\r\n    // where the props get applied\r\n    function getElement(tag) {\r\n        if (tag.ref) {\r\n            return tag.ref;\r\n        }\r\n        let el = document.querySelector(`[data-sm=\"${tag.id}\"]`);\r\n        if (el) {\r\n            if (el.tagName.toLowerCase() !== tag.tag) {\r\n                if (el.parentNode) {\r\n                    // remove the old tag\r\n                    el.parentNode.removeChild(el);\r\n                }\r\n                // add the new tag\r\n                el = document.createElement(tag.tag);\r\n            }\r\n            // use the old tag\r\n            el.removeAttribute(\"data-sm\");\r\n        }\r\n        else {\r\n            // create a new tag\r\n            el = document.createElement(tag.tag);\r\n        }\r\n        return el;\r\n    }\r\n    const actions = {\r\n        addClientTag: (tag) => {\r\n            let tagType = getTagType(tag);\r\n            if (cascadingTags.indexOf(tag.tag) !== -1) {\r\n                //  only cascading tags need to be kept as singletons\r\n                if (!cascadedTagInstances.has(tagType)) {\r\n                    cascadedTagInstances.set(tagType, []);\r\n                }\r\n                let instances = cascadedTagInstances.get(tagType);\r\n                let index = instances.length;\r\n                instances = [...instances, tag];\r\n                // track indices synchronously\r\n                cascadedTagInstances.set(tagType, instances);\r\n                if (!isServer) {\r\n                    let element = getElement(tag);\r\n                    tag.ref = element;\r\n                    spread(element, tag.props);\r\n                    let lastVisited = null;\r\n                    for (var i = index - 1; i >= 0; i--) {\r\n                        if (instances[i] != null) {\r\n                            lastVisited = instances[i];\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (element.parentNode != document.head) {\r\n                        document.head.appendChild(element);\r\n                    }\r\n                    if (lastVisited && lastVisited.ref) {\r\n                        document.head.removeChild(lastVisited.ref);\r\n                    }\r\n                }\r\n                return index;\r\n            }\r\n            if (!isServer) {\r\n                let element = getElement(tag);\r\n                tag.ref = element;\r\n                spread(element, tag.props);\r\n                if (element.parentNode != document.head) {\r\n                    document.head.appendChild(element);\r\n                }\r\n            }\r\n            return -1;\r\n        },\r\n        removeClientTag: (tag, index) => {\r\n            const tagName = getTagType(tag);\r\n            if (tag.ref) {\r\n                const t = cascadedTagInstances.get(tagName);\r\n                if (t) {\r\n                    if (tag.ref.parentNode) {\r\n                        tag.ref.parentNode.removeChild(tag.ref);\r\n                        for (let i = index - 1; i >= 0; i--) {\r\n                            if (t[i] != null) {\r\n                                document.head.appendChild(t[i].ref);\r\n                            }\r\n                        }\r\n                    }\r\n                    t[index] = null;\r\n                    cascadedTagInstances.set(tagName, t);\r\n                }\r\n                else {\r\n                    if (tag.ref.parentNode) {\r\n                        tag.ref.parentNode.removeChild(tag.ref);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    if (isServer) {\r\n        actions.addServerTag = (tagDesc) => {\r\n            const { tags = [] } = props;\r\n            // tweak only cascading tags\r\n            if (cascadingTags.indexOf(tagDesc.tag) !== -1) {\r\n                const index = tags.findIndex(prev => {\r\n                    const prevName = prev.props.name || prev.props.property;\r\n                    const nextName = tagDesc.props.name || tagDesc.props.property;\r\n                    return prev.tag === tagDesc.tag && prevName === nextName;\r\n                });\r\n                if (index !== -1) {\r\n                    tags.splice(index, 1);\r\n                }\r\n            }\r\n            tags.push(tagDesc);\r\n        };\r\n        if (Array.isArray(props.tags) === false) {\r\n            throw Error(\"tags array should be passed to <MetaProvider /> in node\");\r\n        }\r\n    }\r\n    return <MetaContext.Provider value={actions}>{props.children}</MetaContext.Provider>;\r\n};\r\nconst MetaTag = (tag, props, setting) => {\r\n    const id = createUniqueId();\r\n    const c = useContext(MetaContext);\r\n    if (!c)\r\n        throw new Error(\"<MetaProvider /> should be in the tree\");\r\n    useHead({\r\n        tag,\r\n        props,\r\n        setting,\r\n        id,\r\n        get name() {\r\n            return props.name || props.property;\r\n        }\r\n    });\r\n    return null;\r\n};\r\nexport { MetaProvider };\r\nexport function useHead(tagDesc) {\r\n    const { addClientTag, removeClientTag, addServerTag } = useContext(MetaContext);\r\n    createRenderEffect(() => {\r\n        if (!isServer) {\r\n            let index = addClientTag(tagDesc);\r\n            onCleanup(() => removeClientTag(tagDesc, index));\r\n        }\r\n    });\r\n    if (isServer) {\r\n        addServerTag(tagDesc);\r\n        return null;\r\n    }\r\n}\r\nexport function renderTags(tags) {\r\n    return tags\r\n        .map(tag => {\r\n        const keys = Object.keys(tag.props);\r\n        // @ts-expect-error\r\n        const props = keys.map(k => (k === \"children\" ? \"\" : ` ${k}=\"${escape(tag.props[k], true)}\"`)).join(\"\");\r\n        if (tag.props.children) {\r\n            // Tags might contain multiple text children:\r\n            //   <Title>example - {myCompany}</Title>\r\n            const children = Array.isArray(tag.props.children) ? tag.props.children.join(\"\") : tag.props.children;\r\n            if (tag.setting?.escape && typeof children === \"string\") {\r\n                return `<${tag.tag} data-sm=\"${tag.id}\"${props}>${escape(children)}</${tag.tag}>`;\r\n            }\r\n            return `<${tag.tag} data-sm=\"${tag.id}\"${props}>${children}</${tag.tag}>`;\r\n        }\r\n        return `<${tag.tag} data-sm=\"${tag.id}\"${props}/>`;\r\n    })\r\n        .join(\"\");\r\n}\r\nexport const Title = props => MetaTag(\"title\", props, { escape: true });\r\nexport const Style = props => MetaTag(\"style\", props);\r\nexport const Meta = props => MetaTag(\"meta\", props, { escape: true });\r\nexport const Link = props => MetaTag(\"link\", props);\r\nexport const Base = props => MetaTag(\"base\", props);\r\nexport const Stylesheet = props => <Link rel=\"stylesheet\" {...props}/>;\r\n",
      "start": 1691669611614,
      "end": 1691669611614
    },
    {
      "name": "solid",
      "result": "import { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { createComponent as _$createComponent } from \"solid-js/web\";\nimport { createContext, createRenderEffect, createUniqueId, onCleanup, sharedConfig, useContext } from \"solid-js\";\nimport { isServer, spread, escape } from \"solid-js/web\";\nexport const MetaContext = createContext();\nconst cascadingTags = [\"title\", \"meta\"];\nconst getTagType = tag => tag.tag + (tag.name ? `.${tag.name}\"` : \"\");\nconst MetaProvider = props => {\n  if (!isServer && !sharedConfig.context) {\n    const ssrTags = document.head.querySelectorAll(`[data-sm]`);\n    // `forEach` on `NodeList` is not supported in Googlebot, so use a workaround\n    Array.prototype.forEach.call(ssrTags, ssrTag => ssrTag.parentNode.removeChild(ssrTag));\n  }\n  const cascadedTagInstances = new Map();\n  // TODO: use one element for all tags of the same type, just swap out\n  // where the props get applied\n  function getElement(tag) {\n    if (tag.ref) {\n      return tag.ref;\n    }\n    let el = document.querySelector(`[data-sm=\"${tag.id}\"]`);\n    if (el) {\n      if (el.tagName.toLowerCase() !== tag.tag) {\n        if (el.parentNode) {\n          // remove the old tag\n          el.parentNode.removeChild(el);\n        }\n        // add the new tag\n        el = document.createElement(tag.tag);\n      }\n      // use the old tag\n      el.removeAttribute(\"data-sm\");\n    } else {\n      // create a new tag\n      el = document.createElement(tag.tag);\n    }\n    return el;\n  }\n  const actions = {\n    addClientTag: tag => {\n      let tagType = getTagType(tag);\n      if (cascadingTags.indexOf(tag.tag) !== -1) {\n        //  only cascading tags need to be kept as singletons\n        if (!cascadedTagInstances.has(tagType)) {\n          cascadedTagInstances.set(tagType, []);\n        }\n        let instances = cascadedTagInstances.get(tagType);\n        let index = instances.length;\n        instances = [...instances, tag];\n        // track indices synchronously\n        cascadedTagInstances.set(tagType, instances);\n        if (!isServer) {\n          let element = getElement(tag);\n          tag.ref = element;\n          spread(element, tag.props);\n          let lastVisited = null;\n          for (var i = index - 1; i >= 0; i--) {\n            if (instances[i] != null) {\n              lastVisited = instances[i];\n              break;\n            }\n          }\n          if (element.parentNode != document.head) {\n            document.head.appendChild(element);\n          }\n          if (lastVisited && lastVisited.ref) {\n            document.head.removeChild(lastVisited.ref);\n          }\n        }\n        return index;\n      }\n      if (!isServer) {\n        let element = getElement(tag);\n        tag.ref = element;\n        spread(element, tag.props);\n        if (element.parentNode != document.head) {\n          document.head.appendChild(element);\n        }\n      }\n      return -1;\n    },\n    removeClientTag: (tag, index) => {\n      const tagName = getTagType(tag);\n      if (tag.ref) {\n        const t = cascadedTagInstances.get(tagName);\n        if (t) {\n          if (tag.ref.parentNode) {\n            tag.ref.parentNode.removeChild(tag.ref);\n            for (let i = index - 1; i >= 0; i--) {\n              if (t[i] != null) {\n                document.head.appendChild(t[i].ref);\n              }\n            }\n          }\n          t[index] = null;\n          cascadedTagInstances.set(tagName, t);\n        } else {\n          if (tag.ref.parentNode) {\n            tag.ref.parentNode.removeChild(tag.ref);\n          }\n        }\n      }\n    }\n  };\n  if (isServer) {\n    actions.addServerTag = tagDesc => {\n      const {\n        tags = []\n      } = props;\n      // tweak only cascading tags\n      if (cascadingTags.indexOf(tagDesc.tag) !== -1) {\n        const index = tags.findIndex(prev => {\n          const prevName = prev.props.name || prev.props.property;\n          const nextName = tagDesc.props.name || tagDesc.props.property;\n          return prev.tag === tagDesc.tag && prevName === nextName;\n        });\n        if (index !== -1) {\n          tags.splice(index, 1);\n        }\n      }\n      tags.push(tagDesc);\n    };\n    if (Array.isArray(props.tags) === false) {\n      throw Error(\"tags array should be passed to <MetaProvider /> in node\");\n    }\n  }\n  return _$createComponent(MetaContext.Provider, {\n    value: actions,\n    get children() {\n      return props.children;\n    }\n  });\n};\nconst MetaTag = (tag, props, setting) => {\n  const id = createUniqueId();\n  const c = useContext(MetaContext);\n  if (!c) throw new Error(\"<MetaProvider /> should be in the tree\");\n  useHead({\n    tag,\n    props,\n    setting,\n    id,\n    get name() {\n      return props.name || props.property;\n    }\n  });\n  return null;\n};\nexport { MetaProvider };\nexport function useHead(tagDesc) {\n  const {\n    addClientTag,\n    removeClientTag,\n    addServerTag\n  } = useContext(MetaContext);\n  createRenderEffect(() => {\n    if (!isServer) {\n      let index = addClientTag(tagDesc);\n      onCleanup(() => removeClientTag(tagDesc, index));\n    }\n  });\n  if (isServer) {\n    addServerTag(tagDesc);\n    return null;\n  }\n}\nexport function renderTags(tags) {\n  return tags.map(tag => {\n    const keys = Object.keys(tag.props);\n    // @ts-expect-error\n    const props = keys.map(k => k === \"children\" ? \"\" : ` ${k}=\"${escape(tag.props[k], true)}\"`).join(\"\");\n    if (tag.props.children) {\n      // Tags might contain multiple text children:\n      //   <Title>example - {myCompany}</Title>\n      const children = Array.isArray(tag.props.children) ? tag.props.children.join(\"\") : tag.props.children;\n      if (tag.setting?.escape && typeof children === \"string\") {\n        return `<${tag.tag} data-sm=\"${tag.id}\"${props}>${escape(children)}</${tag.tag}>`;\n      }\n      return `<${tag.tag} data-sm=\"${tag.id}\"${props}>${children}</${tag.tag}>`;\n    }\n    return `<${tag.tag} data-sm=\"${tag.id}\"${props}/>`;\n  }).join(\"\");\n}\nexport const Title = props => MetaTag(\"title\", props, {\n  escape: true\n});\nexport const Style = props => MetaTag(\"style\", props);\nexport const Meta = props => MetaTag(\"meta\", props, {\n  escape: true\n});\nexport const Link = props => MetaTag(\"link\", props);\nexport const Base = props => MetaTag(\"base\", props);\nexport const Stylesheet = props => _$createComponent(Link, _$mergeProps({\n  rel: \"stylesheet\"\n}, props));",
      "start": 1691669611614,
      "end": 1691669611637,
      "order": "pre"
    },
    {
      "name": "vite:import-analysis",
      "result": "import { mergeProps as _$mergeProps } from \"/node_modules/.vite/deps/solid-js_web.js?v=1b141ace\";\nimport { createComponent as _$createComponent } from \"/node_modules/.vite/deps/solid-js_web.js?v=1b141ace\";\nimport { createContext, createRenderEffect, createUniqueId, onCleanup, sharedConfig, useContext } from \"/node_modules/.vite/deps/solid-js.js?v=1b141ace\";\nimport { isServer, spread, escape } from \"/node_modules/.vite/deps/solid-js_web.js?v=1b141ace\";\nexport const MetaContext = createContext();\nconst cascadingTags = [\"title\", \"meta\"];\nconst getTagType = tag => tag.tag + (tag.name ? `.${tag.name}\"` : \"\");\nconst MetaProvider = props => {\n  if (!isServer && !sharedConfig.context) {\n    const ssrTags = document.head.querySelectorAll(`[data-sm]`);\n    // `forEach` on `NodeList` is not supported in Googlebot, so use a workaround\n    Array.prototype.forEach.call(ssrTags, ssrTag => ssrTag.parentNode.removeChild(ssrTag));\n  }\n  const cascadedTagInstances = new Map();\n  // TODO: use one element for all tags of the same type, just swap out\n  // where the props get applied\n  function getElement(tag) {\n    if (tag.ref) {\n      return tag.ref;\n    }\n    let el = document.querySelector(`[data-sm=\"${tag.id}\"]`);\n    if (el) {\n      if (el.tagName.toLowerCase() !== tag.tag) {\n        if (el.parentNode) {\n          // remove the old tag\n          el.parentNode.removeChild(el);\n        }\n        // add the new tag\n        el = document.createElement(tag.tag);\n      }\n      // use the old tag\n      el.removeAttribute(\"data-sm\");\n    } else {\n      // create a new tag\n      el = document.createElement(tag.tag);\n    }\n    return el;\n  }\n  const actions = {\n    addClientTag: tag => {\n      let tagType = getTagType(tag);\n      if (cascadingTags.indexOf(tag.tag) !== -1) {\n        //  only cascading tags need to be kept as singletons\n        if (!cascadedTagInstances.has(tagType)) {\n          cascadedTagInstances.set(tagType, []);\n        }\n        let instances = cascadedTagInstances.get(tagType);\n        let index = instances.length;\n        instances = [...instances, tag];\n        // track indices synchronously\n        cascadedTagInstances.set(tagType, instances);\n        if (!isServer) {\n          let element = getElement(tag);\n          tag.ref = element;\n          spread(element, tag.props);\n          let lastVisited = null;\n          for (var i = index - 1; i >= 0; i--) {\n            if (instances[i] != null) {\n              lastVisited = instances[i];\n              break;\n            }\n          }\n          if (element.parentNode != document.head) {\n            document.head.appendChild(element);\n          }\n          if (lastVisited && lastVisited.ref) {\n            document.head.removeChild(lastVisited.ref);\n          }\n        }\n        return index;\n      }\n      if (!isServer) {\n        let element = getElement(tag);\n        tag.ref = element;\n        spread(element, tag.props);\n        if (element.parentNode != document.head) {\n          document.head.appendChild(element);\n        }\n      }\n      return -1;\n    },\n    removeClientTag: (tag, index) => {\n      const tagName = getTagType(tag);\n      if (tag.ref) {\n        const t = cascadedTagInstances.get(tagName);\n        if (t) {\n          if (tag.ref.parentNode) {\n            tag.ref.parentNode.removeChild(tag.ref);\n            for (let i = index - 1; i >= 0; i--) {\n              if (t[i] != null) {\n                document.head.appendChild(t[i].ref);\n              }\n            }\n          }\n          t[index] = null;\n          cascadedTagInstances.set(tagName, t);\n        } else {\n          if (tag.ref.parentNode) {\n            tag.ref.parentNode.removeChild(tag.ref);\n          }\n        }\n      }\n    }\n  };\n  if (isServer) {\n    actions.addServerTag = tagDesc => {\n      const {\n        tags = []\n      } = props;\n      // tweak only cascading tags\n      if (cascadingTags.indexOf(tagDesc.tag) !== -1) {\n        const index = tags.findIndex(prev => {\n          const prevName = prev.props.name || prev.props.property;\n          const nextName = tagDesc.props.name || tagDesc.props.property;\n          return prev.tag === tagDesc.tag && prevName === nextName;\n        });\n        if (index !== -1) {\n          tags.splice(index, 1);\n        }\n      }\n      tags.push(tagDesc);\n    };\n    if (Array.isArray(props.tags) === false) {\n      throw Error(\"tags array should be passed to <MetaProvider /> in node\");\n    }\n  }\n  return _$createComponent(MetaContext.Provider, {\n    value: actions,\n    get children() {\n      return props.children;\n    }\n  });\n};\nconst MetaTag = (tag, props, setting) => {\n  const id = createUniqueId();\n  const c = useContext(MetaContext);\n  if (!c) throw new Error(\"<MetaProvider /> should be in the tree\");\n  useHead({\n    tag,\n    props,\n    setting,\n    id,\n    get name() {\n      return props.name || props.property;\n    }\n  });\n  return null;\n};\nexport { MetaProvider };\nexport function useHead(tagDesc) {\n  const {\n    addClientTag,\n    removeClientTag,\n    addServerTag\n  } = useContext(MetaContext);\n  createRenderEffect(() => {\n    if (!isServer) {\n      let index = addClientTag(tagDesc);\n      onCleanup(() => removeClientTag(tagDesc, index));\n    }\n  });\n  if (isServer) {\n    addServerTag(tagDesc);\n    return null;\n  }\n}\nexport function renderTags(tags) {\n  return tags.map(tag => {\n    const keys = Object.keys(tag.props);\n    // @ts-expect-error\n    const props = keys.map(k => k === \"children\" ? \"\" : ` ${k}=\"${escape(tag.props[k], true)}\"`).join(\"\");\n    if (tag.props.children) {\n      // Tags might contain multiple text children:\n      //   <Title>example - {myCompany}</Title>\n      const children = Array.isArray(tag.props.children) ? tag.props.children.join(\"\") : tag.props.children;\n      if (tag.setting?.escape && typeof children === \"string\") {\n        return `<${tag.tag} data-sm=\"${tag.id}\"${props}>${escape(children)}</${tag.tag}>`;\n      }\n      return `<${tag.tag} data-sm=\"${tag.id}\"${props}>${children}</${tag.tag}>`;\n    }\n    return `<${tag.tag} data-sm=\"${tag.id}\"${props}/>`;\n  }).join(\"\");\n}\nexport const Title = props => MetaTag(\"title\", props, {\n  escape: true\n});\nexport const Style = props => MetaTag(\"style\", props);\nexport const Meta = props => MetaTag(\"meta\", props, {\n  escape: true\n});\nexport const Link = props => MetaTag(\"link\", props);\nexport const Base = props => MetaTag(\"base\", props);\nexport const Stylesheet = props => _$createComponent(Link, _$mergeProps({\n  rel: \"stylesheet\"\n}, props));",
      "start": 1691669611637,
      "end": 1691669611638,
      "order": "normal"
    }
  ]
}
