{
  "resolvedId": "/@solid-refresh",
  "transforms": [
    {
      "name": "solid",
      "result": "import { $DEVCOMP, createMemo, untrack, createSignal, DEV } from 'solid-js';\r\n\r\nfunction setComponentProperty(component, key, value) {\r\n    const descriptor = Object.getOwnPropertyDescriptor(component, key);\r\n    if (descriptor) {\r\n        Object.defineProperty(component, key, Object.assign(Object.assign({}, descriptor), { value }));\r\n    }\r\n    else {\r\n        Object.defineProperty(component, key, {\r\n            value,\r\n            writable: false,\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n}\r\nfunction createProxy(source, name, location) {\r\n    const refreshName = `[solid-refresh]${name}`;\r\n    function HMRComp(props) {\r\n        const s = source();\r\n        if (!s || $DEVCOMP in s) {\r\n            return createMemo(() => {\r\n                const c = source();\r\n                if (c) {\r\n                    return untrack(() => c(props));\r\n                }\r\n                return undefined;\r\n            }, {\r\n                name: refreshName\r\n            });\r\n        }\r\n        // no $DEVCOMP means it did not go through devComponent so source() is a regular function, not a component\r\n        return s(props);\r\n    }\r\n    setComponentProperty(HMRComp, 'name', refreshName);\r\n    if (location) {\r\n        setComponentProperty(HMRComp, 'location', location);\r\n    }\r\n    return new Proxy(HMRComp, {\r\n        get(_, property) {\r\n            if (property === 'location' || property === 'name') {\r\n                return HMRComp[property];\r\n            }\r\n            return source()[property];\r\n        },\r\n        set(_, property, value) {\r\n            source()[property] = value;\r\n            return true;\r\n        }\r\n    });\r\n}\r\n\r\nfunction isListUpdated(a, b) {\r\n    if (a == null && b != null) {\r\n        return true;\r\n    }\r\n    if (a != null && b == null) {\r\n        return true;\r\n    }\r\n    if (a && b) {\r\n        const aKeys = Object.keys(a);\r\n        const bKeys = Object.keys(b);\r\n        // Check if both objects has the same amount of keys\r\n        if (aKeys.length !== bKeys.length) {\r\n            return true;\r\n        }\r\n        // Merge keys\r\n        const keys = new Set([...aKeys, ...bKeys]);\r\n        // Now check if merged keys has the same amount of keys as the other two\r\n        // for example: { a, b } and { a, c } produces { a, b, c }\r\n        if (keys.size !== aKeys.length) {\r\n            return true;\r\n        }\r\n        // Now compare each items\r\n        for (const key of keys.keys()) {\r\n            if (!Object.is(a[key], b[key])) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction $$registry() {\r\n    return {\r\n        components: new Map(),\r\n        contexts: new Map()\r\n    };\r\n}\r\nfunction $$component(registry, id, component, options = {}) {\r\n    const [comp, setComp] = createSignal(component, { internal: true });\r\n    const proxy = createProxy(comp, id, options.location);\r\n    registry.components.set(id, Object.assign({ id,\r\n        component,\r\n        proxy, update: setComp }, options));\r\n    return proxy;\r\n}\r\nfunction $$context(registry, id, context) {\r\n    registry.contexts.set(id, {\r\n        id,\r\n        context\r\n    });\r\n    return context;\r\n}\r\nfunction patchComponent(oldData, newData) {\r\n    // Check if incoming module has signature\r\n    if (newData.signature) {\r\n        // Compare signatures\r\n        if (newData.signature !== oldData.signature ||\r\n            isListUpdated(newData.dependencies, oldData.dependencies)) {\r\n            // Replace signatures and dependencies\r\n            oldData.dependencies = newData.dependencies;\r\n            oldData.signature = newData.signature;\r\n            // Remount\r\n            oldData.update(() => newData.component);\r\n        }\r\n    }\r\n    else {\r\n        // No granular update, remount\r\n        oldData.update(() => newData.component);\r\n    }\r\n    // Always rely on the first proxy\r\n    // This is to allow modules newly importing\r\n    // the updated version to still be able\r\n    // to render the latest version despite\r\n    // not receiving the first proxy\r\n    newData.update(() => oldData.proxy);\r\n}\r\nfunction patchComponents(oldData, newData) {\r\n    const components = new Set([...oldData.components.keys(), ...newData.components.keys()]);\r\n    for (const key of components) {\r\n        const oldComponent = oldData.components.get(key);\r\n        const newComponent = newData.components.get(key);\r\n        if (oldComponent) {\r\n            if (newComponent) {\r\n                patchComponent(oldComponent, newComponent);\r\n            }\r\n            else {\r\n                // We need to invalidate\r\n                return true;\r\n            }\r\n        }\r\n        else if (newComponent) {\r\n            oldData.components.set(key, newComponent);\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction patchContext(oldData, newData) {\r\n    oldData.context.defaultValue = newData.context.defaultValue;\r\n    newData.context.id = oldData.context.id;\r\n    newData.context.Provider = oldData.context.Provider;\r\n}\r\nfunction patchContexts(oldData, newData) {\r\n    const contexts = new Set([...oldData.contexts.keys(), ...newData.contexts.keys()]);\r\n    for (const key of contexts.keys()) {\r\n        const oldContext = oldData.contexts.get(key);\r\n        const newContext = newData.contexts.get(key);\r\n        if (oldContext) {\r\n            if (newContext) {\r\n                patchContext(oldContext, newContext);\r\n            }\r\n            else {\r\n                // We need to invalidate\r\n                return true;\r\n            }\r\n        }\r\n        else if (newContext) {\r\n            oldData.contexts.set(key, newContext);\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction patchRegistry(oldRegistry, newRegistry) {\r\n    const shouldInvalidateByContext = patchContexts(oldRegistry, newRegistry);\r\n    const shouldInvalidateByComponents = patchComponents(oldRegistry, newRegistry);\r\n    // In the future we may add other HMR features here\r\n    return shouldInvalidateByComponents || shouldInvalidateByContext;\r\n}\r\nconst SOLID_REFRESH = 'solid-refresh';\r\nconst SOLID_REFRESH_PREV = 'solid-refresh-prev';\r\nfunction $$decline(...[type, hot, inline]) {\r\n    switch (type) {\r\n        case 'esm':\r\n            // Snowpack's ESM assumes invalidate as a normal page reload\r\n            // decline should be better\r\n            if (inline) {\r\n                hot.invalidate();\r\n            }\r\n            else {\r\n                hot.decline();\r\n            }\r\n            break;\r\n        case 'vite':\r\n            // Vite is no-op on decline, just call invalidate\r\n            if (inline) {\r\n                hot.invalidate();\r\n            }\r\n            else {\r\n                hot.accept(() => {\r\n                    hot.invalidate();\r\n                });\r\n            }\r\n            break;\r\n        case 'rspack-esm':\r\n        case 'webpack5':\r\n            if (inline) {\r\n                hot.invalidate();\r\n            }\r\n            else {\r\n                hot.decline();\r\n            }\r\n            break;\r\n        case 'standard':\r\n            // Some implementations do not have decline/invalidate\r\n            if (inline) {\r\n                if (hot.invalidate) {\r\n                    hot.invalidate();\r\n                }\r\n                else {\r\n                    window.location.reload();\r\n                }\r\n            }\r\n            else if (hot.decline) {\r\n                hot.decline();\r\n            }\r\n            else {\r\n                hot.accept(() => {\r\n                    if (hot.invalidate) {\r\n                        hot.invalidate();\r\n                    }\r\n                    else {\r\n                        window.location.reload();\r\n                    }\r\n                });\r\n            }\r\n            break;\r\n    }\r\n}\r\nlet warned = false;\r\nfunction shouldWarnAndDecline() {\r\n    const result = DEV && Object.keys(DEV).length;\r\n    if (result) {\r\n        return false;\r\n    }\r\n    if (!warned) {\r\n        console.warn(\"To use solid-refresh, you need to use the dev build of SolidJS. Make sure your build system supports package.json conditional exports and has the 'development' condition turned on.\");\r\n        warned = true;\r\n    }\r\n    return true;\r\n}\r\nfunction $$refreshESM(type, hot, registry) {\r\n    if (shouldWarnAndDecline()) {\r\n        $$decline(type, hot);\r\n    }\r\n    else if (hot.data) {\r\n        hot.data[SOLID_REFRESH] = hot.data[SOLID_REFRESH] || registry;\r\n        hot.data[SOLID_REFRESH_PREV] = registry;\r\n        hot.accept(mod => {\r\n            if (mod == null || patchRegistry(hot.data[SOLID_REFRESH], hot.data[SOLID_REFRESH_PREV])) {\r\n                hot.invalidate();\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // I guess just decline if hot.data doesn't exist\r\n        $$decline(type, hot);\r\n    }\r\n}\r\nfunction $$refreshStandard(type, hot, registry) {\r\n    if (shouldWarnAndDecline()) {\r\n        $$decline(type, hot);\r\n    }\r\n    else {\r\n        const current = hot.data;\r\n        if (current && current[SOLID_REFRESH]) {\r\n            if (patchRegistry(current[SOLID_REFRESH], registry)) {\r\n                $$decline(type, hot, true);\r\n            }\r\n        }\r\n        hot.dispose((data) => {\r\n            data[SOLID_REFRESH] = current ? current[SOLID_REFRESH] : registry;\r\n        });\r\n        hot.accept();\r\n    }\r\n}\r\nfunction $$refresh(...[type, hot, registry]) {\r\n    switch (type) {\r\n        case 'esm':\r\n        case 'vite':\r\n            $$refreshESM(type, hot, registry);\r\n            break;\r\n        case 'standard':\r\n        case 'webpack5':\r\n        case 'rspack-esm':\r\n            $$refreshStandard(type, hot, registry);\r\n            break;\r\n    }\r\n}\r\n\r\nexport { $$component, $$context, $$decline, $$refresh, $$registry };\r\n",
      "start": 1691669611650,
      "end": 1691669611650
    },
    {
      "name": "vite:import-analysis",
      "result": "import { $DEVCOMP, createMemo, untrack, createSignal, DEV } from \"/node_modules/.vite/deps/solid-js.js?v=1b141ace\";\r\n\r\nfunction setComponentProperty(component, key, value) {\r\n    const descriptor = Object.getOwnPropertyDescriptor(component, key);\r\n    if (descriptor) {\r\n        Object.defineProperty(component, key, Object.assign(Object.assign({}, descriptor), { value }));\r\n    }\r\n    else {\r\n        Object.defineProperty(component, key, {\r\n            value,\r\n            writable: false,\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n}\r\nfunction createProxy(source, name, location) {\r\n    const refreshName = `[solid-refresh]${name}`;\r\n    function HMRComp(props) {\r\n        const s = source();\r\n        if (!s || $DEVCOMP in s) {\r\n            return createMemo(() => {\r\n                const c = source();\r\n                if (c) {\r\n                    return untrack(() => c(props));\r\n                }\r\n                return undefined;\r\n            }, {\r\n                name: refreshName\r\n            });\r\n        }\r\n        // no $DEVCOMP means it did not go through devComponent so source() is a regular function, not a component\r\n        return s(props);\r\n    }\r\n    setComponentProperty(HMRComp, 'name', refreshName);\r\n    if (location) {\r\n        setComponentProperty(HMRComp, 'location', location);\r\n    }\r\n    return new Proxy(HMRComp, {\r\n        get(_, property) {\r\n            if (property === 'location' || property === 'name') {\r\n                return HMRComp[property];\r\n            }\r\n            return source()[property];\r\n        },\r\n        set(_, property, value) {\r\n            source()[property] = value;\r\n            return true;\r\n        }\r\n    });\r\n}\r\n\r\nfunction isListUpdated(a, b) {\r\n    if (a == null && b != null) {\r\n        return true;\r\n    }\r\n    if (a != null && b == null) {\r\n        return true;\r\n    }\r\n    if (a && b) {\r\n        const aKeys = Object.keys(a);\r\n        const bKeys = Object.keys(b);\r\n        // Check if both objects has the same amount of keys\r\n        if (aKeys.length !== bKeys.length) {\r\n            return true;\r\n        }\r\n        // Merge keys\r\n        const keys = new Set([...aKeys, ...bKeys]);\r\n        // Now check if merged keys has the same amount of keys as the other two\r\n        // for example: { a, b } and { a, c } produces { a, b, c }\r\n        if (keys.size !== aKeys.length) {\r\n            return true;\r\n        }\r\n        // Now compare each items\r\n        for (const key of keys.keys()) {\r\n            if (!Object.is(a[key], b[key])) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction $$registry() {\r\n    return {\r\n        components: new Map(),\r\n        contexts: new Map()\r\n    };\r\n}\r\nfunction $$component(registry, id, component, options = {}) {\r\n    const [comp, setComp] = createSignal(component, { internal: true });\r\n    const proxy = createProxy(comp, id, options.location);\r\n    registry.components.set(id, Object.assign({ id,\r\n        component,\r\n        proxy, update: setComp }, options));\r\n    return proxy;\r\n}\r\nfunction $$context(registry, id, context) {\r\n    registry.contexts.set(id, {\r\n        id,\r\n        context\r\n    });\r\n    return context;\r\n}\r\nfunction patchComponent(oldData, newData) {\r\n    // Check if incoming module has signature\r\n    if (newData.signature) {\r\n        // Compare signatures\r\n        if (newData.signature !== oldData.signature ||\r\n            isListUpdated(newData.dependencies, oldData.dependencies)) {\r\n            // Replace signatures and dependencies\r\n            oldData.dependencies = newData.dependencies;\r\n            oldData.signature = newData.signature;\r\n            // Remount\r\n            oldData.update(() => newData.component);\r\n        }\r\n    }\r\n    else {\r\n        // No granular update, remount\r\n        oldData.update(() => newData.component);\r\n    }\r\n    // Always rely on the first proxy\r\n    // This is to allow modules newly importing\r\n    // the updated version to still be able\r\n    // to render the latest version despite\r\n    // not receiving the first proxy\r\n    newData.update(() => oldData.proxy);\r\n}\r\nfunction patchComponents(oldData, newData) {\r\n    const components = new Set([...oldData.components.keys(), ...newData.components.keys()]);\r\n    for (const key of components) {\r\n        const oldComponent = oldData.components.get(key);\r\n        const newComponent = newData.components.get(key);\r\n        if (oldComponent) {\r\n            if (newComponent) {\r\n                patchComponent(oldComponent, newComponent);\r\n            }\r\n            else {\r\n                // We need to invalidate\r\n                return true;\r\n            }\r\n        }\r\n        else if (newComponent) {\r\n            oldData.components.set(key, newComponent);\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction patchContext(oldData, newData) {\r\n    oldData.context.defaultValue = newData.context.defaultValue;\r\n    newData.context.id = oldData.context.id;\r\n    newData.context.Provider = oldData.context.Provider;\r\n}\r\nfunction patchContexts(oldData, newData) {\r\n    const contexts = new Set([...oldData.contexts.keys(), ...newData.contexts.keys()]);\r\n    for (const key of contexts.keys()) {\r\n        const oldContext = oldData.contexts.get(key);\r\n        const newContext = newData.contexts.get(key);\r\n        if (oldContext) {\r\n            if (newContext) {\r\n                patchContext(oldContext, newContext);\r\n            }\r\n            else {\r\n                // We need to invalidate\r\n                return true;\r\n            }\r\n        }\r\n        else if (newContext) {\r\n            oldData.contexts.set(key, newContext);\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction patchRegistry(oldRegistry, newRegistry) {\r\n    const shouldInvalidateByContext = patchContexts(oldRegistry, newRegistry);\r\n    const shouldInvalidateByComponents = patchComponents(oldRegistry, newRegistry);\r\n    // In the future we may add other HMR features here\r\n    return shouldInvalidateByComponents || shouldInvalidateByContext;\r\n}\r\nconst SOLID_REFRESH = 'solid-refresh';\r\nconst SOLID_REFRESH_PREV = 'solid-refresh-prev';\r\nfunction $$decline(...[type, hot, inline]) {\r\n    switch (type) {\r\n        case 'esm':\r\n            // Snowpack's ESM assumes invalidate as a normal page reload\r\n            // decline should be better\r\n            if (inline) {\r\n                hot.invalidate();\r\n            }\r\n            else {\r\n                hot.decline();\r\n            }\r\n            break;\r\n        case 'vite':\r\n            // Vite is no-op on decline, just call invalidate\r\n            if (inline) {\r\n                hot.invalidate();\r\n            }\r\n            else {\r\n                hot.accept(() => {\r\n                    hot.invalidate();\r\n                });\r\n            }\r\n            break;\r\n        case 'rspack-esm':\r\n        case 'webpack5':\r\n            if (inline) {\r\n                hot.invalidate();\r\n            }\r\n            else {\r\n                hot.decline();\r\n            }\r\n            break;\r\n        case 'standard':\r\n            // Some implementations do not have decline/invalidate\r\n            if (inline) {\r\n                if (hot.invalidate) {\r\n                    hot.invalidate();\r\n                }\r\n                else {\r\n                    window.location.reload();\r\n                }\r\n            }\r\n            else if (hot.decline) {\r\n                hot.decline();\r\n            }\r\n            else {\r\n                hot.accept(() => {\r\n                    if (hot.invalidate) {\r\n                        hot.invalidate();\r\n                    }\r\n                    else {\r\n                        window.location.reload();\r\n                    }\r\n                });\r\n            }\r\n            break;\r\n    }\r\n}\r\nlet warned = false;\r\nfunction shouldWarnAndDecline() {\r\n    const result = DEV && Object.keys(DEV).length;\r\n    if (result) {\r\n        return false;\r\n    }\r\n    if (!warned) {\r\n        console.warn(\"To use solid-refresh, you need to use the dev build of SolidJS. Make sure your build system supports package.json conditional exports and has the 'development' condition turned on.\");\r\n        warned = true;\r\n    }\r\n    return true;\r\n}\r\nfunction $$refreshESM(type, hot, registry) {\r\n    if (shouldWarnAndDecline()) {\r\n        $$decline(type, hot);\r\n    }\r\n    else if (hot.data) {\r\n        hot.data[SOLID_REFRESH] = hot.data[SOLID_REFRESH] || registry;\r\n        hot.data[SOLID_REFRESH_PREV] = registry;\r\n        hot.accept(mod => {\r\n            if (mod == null || patchRegistry(hot.data[SOLID_REFRESH], hot.data[SOLID_REFRESH_PREV])) {\r\n                hot.invalidate();\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // I guess just decline if hot.data doesn't exist\r\n        $$decline(type, hot);\r\n    }\r\n}\r\nfunction $$refreshStandard(type, hot, registry) {\r\n    if (shouldWarnAndDecline()) {\r\n        $$decline(type, hot);\r\n    }\r\n    else {\r\n        const current = hot.data;\r\n        if (current && current[SOLID_REFRESH]) {\r\n            if (patchRegistry(current[SOLID_REFRESH], registry)) {\r\n                $$decline(type, hot, true);\r\n            }\r\n        }\r\n        hot.dispose((data) => {\r\n            data[SOLID_REFRESH] = current ? current[SOLID_REFRESH] : registry;\r\n        });\r\n        hot.accept();\r\n    }\r\n}\r\nfunction $$refresh(...[type, hot, registry]) {\r\n    switch (type) {\r\n        case 'esm':\r\n        case 'vite':\r\n            $$refreshESM(type, hot, registry);\r\n            break;\r\n        case 'standard':\r\n        case 'webpack5':\r\n        case 'rspack-esm':\r\n            $$refreshStandard(type, hot, registry);\r\n            break;\r\n    }\r\n}\r\n\r\nexport { $$component, $$context, $$decline, $$refresh, $$registry };\r\n",
      "start": 1691669611651,
      "end": 1691669611651,
      "order": "normal"
    }
  ]
}
