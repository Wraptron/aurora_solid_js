{
  "resolvedId": "C:/solid js/authentication-client/node_modules/@solidjs/router/dist/integration.js?v=1b141ace",
  "transforms": [
    {
      "name": "__load__",
      "result": "import { createSignal, onCleanup } from \"solid-js\";\r\nfunction bindEvent(target, type, handler) {\r\n    target.addEventListener(type, handler);\r\n    return () => target.removeEventListener(type, handler);\r\n}\r\nfunction intercept([value, setValue], get, set) {\r\n    return [get ? () => get(value()) : value, set ? (v) => setValue(set(v)) : setValue];\r\n}\r\nfunction querySelector(selector) {\r\n    // Guard against selector being an invalid CSS selector\r\n    try {\r\n        return document.querySelector(selector);\r\n    }\r\n    catch (e) {\r\n        return null;\r\n    }\r\n}\r\nfunction scrollToHash(hash, fallbackTop) {\r\n    const el = querySelector(`#${hash}`);\r\n    if (el) {\r\n        el.scrollIntoView();\r\n    }\r\n    else if (fallbackTop) {\r\n        window.scrollTo(0, 0);\r\n    }\r\n}\r\nexport function createMemoryHistory() {\r\n    const entries = [\"/\"];\r\n    let index = 0;\r\n    const listeners = [];\r\n    const go = (n) => {\r\n        // https://github.com/remix-run/react-router/blob/682810ca929d0e3c64a76f8d6e465196b7a2ac58/packages/router/history.ts#L245\r\n        index = Math.max(0, Math.min(index + n, entries.length - 1));\r\n        const value = entries[index];\r\n        listeners.forEach(listener => listener(value));\r\n    };\r\n    return {\r\n        get: () => entries[index],\r\n        set: ({ value, scroll, replace }) => {\r\n            if (replace) {\r\n                entries[index] = value;\r\n            }\r\n            else {\r\n                entries.splice(index + 1, entries.length - index, value);\r\n                index++;\r\n            }\r\n            if (scroll) {\r\n                scrollToHash(value.split(\"#\")[1] || \"\", true);\r\n            }\r\n        },\r\n        back: () => {\r\n            go(-1);\r\n        },\r\n        forward: () => {\r\n            go(1);\r\n        },\r\n        go,\r\n        listen: (listener) => {\r\n            listeners.push(listener);\r\n            return () => {\r\n                const index = listeners.indexOf(listener);\r\n                listeners.splice(index, 1);\r\n            };\r\n        }\r\n    };\r\n}\r\nexport function createIntegration(get, set, init, utils) {\r\n    let ignore = false;\r\n    const wrap = (value) => (typeof value === \"string\" ? { value } : value);\r\n    const signal = intercept(createSignal(wrap(get()), { equals: (a, b) => a.value === b.value }), undefined, next => {\r\n        !ignore && set(next);\r\n        return next;\r\n    });\r\n    init &&\r\n        onCleanup(init((value = get()) => {\r\n            ignore = true;\r\n            signal[1](wrap(value));\r\n            ignore = false;\r\n        }));\r\n    return {\r\n        signal,\r\n        utils\r\n    };\r\n}\r\nexport function normalizeIntegration(integration) {\r\n    if (!integration) {\r\n        return {\r\n            signal: createSignal({ value: \"\" })\r\n        };\r\n    }\r\n    else if (Array.isArray(integration)) {\r\n        return {\r\n            signal: integration\r\n        };\r\n    }\r\n    return integration;\r\n}\r\nexport function staticIntegration(obj) {\r\n    return {\r\n        signal: [() => obj, next => Object.assign(obj, next)]\r\n    };\r\n}\r\nexport function pathIntegration() {\r\n    return createIntegration(() => ({\r\n        value: window.location.pathname + window.location.search + window.location.hash,\r\n        state: history.state\r\n    }), ({ value, replace, scroll, state }) => {\r\n        if (replace) {\r\n            window.history.replaceState(state, \"\", value);\r\n        }\r\n        else {\r\n            window.history.pushState(state, \"\", value);\r\n        }\r\n        scrollToHash(window.location.hash.slice(1), scroll);\r\n    }, notify => bindEvent(window, \"popstate\", () => notify()), {\r\n        go: delta => window.history.go(delta)\r\n    });\r\n}\r\nexport function hashIntegration() {\r\n    return createIntegration(() => window.location.hash.slice(1), ({ value, replace, scroll, state }) => {\r\n        if (replace) {\r\n            window.history.replaceState(state, \"\", \"#\" + value);\r\n        }\r\n        else {\r\n            window.location.hash = value;\r\n        }\r\n        const hashIndex = value.indexOf(\"#\");\r\n        const hash = hashIndex >= 0 ? value.slice(hashIndex + 1) : \"\";\r\n        scrollToHash(hash, scroll);\r\n    }, notify => bindEvent(window, \"hashchange\", () => notify()), {\r\n        go: delta => window.history.go(delta),\r\n        renderPath: path => `#${path}`,\r\n        parsePath: str => {\r\n            const to = str.replace(/^.*?#/, \"\");\r\n            // Hash-only hrefs like `#foo` from plain anchors will come in as `/#foo` whereas a link to\r\n            // `/foo` will be `/#/foo`. Check if the to starts with a `/` and if not append it as a hash\r\n            // to the current path so we can handle these in-page anchors correctly.\r\n            if (!to.startsWith(\"/\")) {\r\n                const [, path = \"/\"] = window.location.hash.split(\"#\", 2);\r\n                return `${path}#${to}`;\r\n            }\r\n            return to;\r\n        }\r\n    });\r\n}\r\nexport function memoryIntegration() {\r\n    const memoryHistory = createMemoryHistory();\r\n    return createIntegration(memoryHistory.get, memoryHistory.set, memoryHistory.listen, {\r\n        go: memoryHistory.go\r\n    });\r\n}\r\n",
      "start": 1691669611683,
      "end": 1691669611683
    },
    {
      "name": "vite:import-analysis",
      "result": "import { createSignal, onCleanup } from \"/node_modules/.vite/deps/solid-js.js?v=1b141ace\";\r\nfunction bindEvent(target, type, handler) {\r\n    target.addEventListener(type, handler);\r\n    return () => target.removeEventListener(type, handler);\r\n}\r\nfunction intercept([value, setValue], get, set) {\r\n    return [get ? () => get(value()) : value, set ? (v) => setValue(set(v)) : setValue];\r\n}\r\nfunction querySelector(selector) {\r\n    // Guard against selector being an invalid CSS selector\r\n    try {\r\n        return document.querySelector(selector);\r\n    }\r\n    catch (e) {\r\n        return null;\r\n    }\r\n}\r\nfunction scrollToHash(hash, fallbackTop) {\r\n    const el = querySelector(`#${hash}`);\r\n    if (el) {\r\n        el.scrollIntoView();\r\n    }\r\n    else if (fallbackTop) {\r\n        window.scrollTo(0, 0);\r\n    }\r\n}\r\nexport function createMemoryHistory() {\r\n    const entries = [\"/\"];\r\n    let index = 0;\r\n    const listeners = [];\r\n    const go = (n) => {\r\n        // https://github.com/remix-run/react-router/blob/682810ca929d0e3c64a76f8d6e465196b7a2ac58/packages/router/history.ts#L245\r\n        index = Math.max(0, Math.min(index + n, entries.length - 1));\r\n        const value = entries[index];\r\n        listeners.forEach(listener => listener(value));\r\n    };\r\n    return {\r\n        get: () => entries[index],\r\n        set: ({ value, scroll, replace }) => {\r\n            if (replace) {\r\n                entries[index] = value;\r\n            }\r\n            else {\r\n                entries.splice(index + 1, entries.length - index, value);\r\n                index++;\r\n            }\r\n            if (scroll) {\r\n                scrollToHash(value.split(\"#\")[1] || \"\", true);\r\n            }\r\n        },\r\n        back: () => {\r\n            go(-1);\r\n        },\r\n        forward: () => {\r\n            go(1);\r\n        },\r\n        go,\r\n        listen: (listener) => {\r\n            listeners.push(listener);\r\n            return () => {\r\n                const index = listeners.indexOf(listener);\r\n                listeners.splice(index, 1);\r\n            };\r\n        }\r\n    };\r\n}\r\nexport function createIntegration(get, set, init, utils) {\r\n    let ignore = false;\r\n    const wrap = (value) => (typeof value === \"string\" ? { value } : value);\r\n    const signal = intercept(createSignal(wrap(get()), { equals: (a, b) => a.value === b.value }), undefined, next => {\r\n        !ignore && set(next);\r\n        return next;\r\n    });\r\n    init &&\r\n        onCleanup(init((value = get()) => {\r\n            ignore = true;\r\n            signal[1](wrap(value));\r\n            ignore = false;\r\n        }));\r\n    return {\r\n        signal,\r\n        utils\r\n    };\r\n}\r\nexport function normalizeIntegration(integration) {\r\n    if (!integration) {\r\n        return {\r\n            signal: createSignal({ value: \"\" })\r\n        };\r\n    }\r\n    else if (Array.isArray(integration)) {\r\n        return {\r\n            signal: integration\r\n        };\r\n    }\r\n    return integration;\r\n}\r\nexport function staticIntegration(obj) {\r\n    return {\r\n        signal: [() => obj, next => Object.assign(obj, next)]\r\n    };\r\n}\r\nexport function pathIntegration() {\r\n    return createIntegration(() => ({\r\n        value: window.location.pathname + window.location.search + window.location.hash,\r\n        state: history.state\r\n    }), ({ value, replace, scroll, state }) => {\r\n        if (replace) {\r\n            window.history.replaceState(state, \"\", value);\r\n        }\r\n        else {\r\n            window.history.pushState(state, \"\", value);\r\n        }\r\n        scrollToHash(window.location.hash.slice(1), scroll);\r\n    }, notify => bindEvent(window, \"popstate\", () => notify()), {\r\n        go: delta => window.history.go(delta)\r\n    });\r\n}\r\nexport function hashIntegration() {\r\n    return createIntegration(() => window.location.hash.slice(1), ({ value, replace, scroll, state }) => {\r\n        if (replace) {\r\n            window.history.replaceState(state, \"\", \"#\" + value);\r\n        }\r\n        else {\r\n            window.location.hash = value;\r\n        }\r\n        const hashIndex = value.indexOf(\"#\");\r\n        const hash = hashIndex >= 0 ? value.slice(hashIndex + 1) : \"\";\r\n        scrollToHash(hash, scroll);\r\n    }, notify => bindEvent(window, \"hashchange\", () => notify()), {\r\n        go: delta => window.history.go(delta),\r\n        renderPath: path => `#${path}`,\r\n        parsePath: str => {\r\n            const to = str.replace(/^.*?#/, \"\");\r\n            // Hash-only hrefs like `#foo` from plain anchors will come in as `/#foo` whereas a link to\r\n            // `/foo` will be `/#/foo`. Check if the to starts with a `/` and if not append it as a hash\r\n            // to the current path so we can handle these in-page anchors correctly.\r\n            if (!to.startsWith(\"/\")) {\r\n                const [, path = \"/\"] = window.location.hash.split(\"#\", 2);\r\n                return `${path}#${to}`;\r\n            }\r\n            return to;\r\n        }\r\n    });\r\n}\r\nexport function memoryIntegration() {\r\n    const memoryHistory = createMemoryHistory();\r\n    return createIntegration(memoryHistory.get, memoryHistory.set, memoryHistory.listen, {\r\n        go: memoryHistory.go\r\n    });\r\n}\r\n",
      "start": 1691669611683,
      "end": 1691669611684,
      "order": "normal"
    }
  ]
}
