{
  "resolvedId": "C:/solid js/authentication-client/node_modules/@solidjs/router/dist/utils.js",
  "transforms": [
    {
      "name": "__load__",
      "result": "import { createMemo, getOwner, runWithOwner } from \"solid-js\";\r\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\r\nconst trimPathRegex = /^\\/+|(\\/)\\/+$/g;\r\nexport function normalizePath(path, omitSlash = false) {\r\n    const s = path.replace(trimPathRegex, \"$1\");\r\n    return s ? (omitSlash || /^[?#]/.test(s) ? s : \"/\" + s) : \"\";\r\n}\r\nexport function resolvePath(base, path, from) {\r\n    if (hasSchemeRegex.test(path)) {\r\n        return undefined;\r\n    }\r\n    const basePath = normalizePath(base);\r\n    const fromPath = from && normalizePath(from);\r\n    let result = \"\";\r\n    if (!fromPath || path.startsWith(\"/\")) {\r\n        result = basePath;\r\n    }\r\n    else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\r\n        result = basePath + fromPath;\r\n    }\r\n    else {\r\n        result = fromPath;\r\n    }\r\n    return (result || \"/\") + normalizePath(path, !result);\r\n}\r\nexport function invariant(value, message) {\r\n    if (value == null) {\r\n        throw new Error(message);\r\n    }\r\n    return value;\r\n}\r\nexport function joinPaths(from, to) {\r\n    return normalizePath(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalizePath(to);\r\n}\r\nexport function extractSearchParams(url) {\r\n    const params = {};\r\n    url.searchParams.forEach((value, key) => {\r\n        params[key] = value;\r\n    });\r\n    return params;\r\n}\r\nexport function createMatcher(path, partial, matchFilters) {\r\n    const [pattern, splat] = path.split(\"/*\", 2);\r\n    const segments = pattern.split(\"/\").filter(Boolean);\r\n    const len = segments.length;\r\n    return (location) => {\r\n        const locSegments = location.split(\"/\").filter(Boolean);\r\n        const lenDiff = locSegments.length - len;\r\n        if (lenDiff < 0 || (lenDiff > 0 && splat === undefined && !partial)) {\r\n            return null;\r\n        }\r\n        const match = {\r\n            path: len ? \"\" : \"/\",\r\n            params: {}\r\n        };\r\n        const matchFilter = (s) => matchFilters === undefined ? undefined : matchFilters[s];\r\n        for (let i = 0; i < len; i++) {\r\n            const segment = segments[i];\r\n            const locSegment = locSegments[i];\r\n            const dynamic = segment[0] === \":\";\r\n            const key = dynamic ? segment.slice(1) : segment;\r\n            if (dynamic && matchSegment(locSegment, matchFilter(key))) {\r\n                match.params[key] = locSegment;\r\n            }\r\n            else if (dynamic || !matchSegment(locSegment, segment)) {\r\n                return null;\r\n            }\r\n            match.path += `/${locSegment}`;\r\n        }\r\n        if (splat) {\r\n            const remainder = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\r\n            if (matchSegment(remainder, matchFilter(splat))) {\r\n                match.params[splat] = remainder;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        return match;\r\n    };\r\n}\r\nfunction matchSegment(input, filter) {\r\n    const isEqual = (s) => s.localeCompare(input, undefined, { sensitivity: \"base\" }) === 0;\r\n    if (filter === undefined) {\r\n        return true;\r\n    }\r\n    else if (typeof filter === \"string\") {\r\n        return isEqual(filter);\r\n    }\r\n    else if (typeof filter === \"function\") {\r\n        return filter(input);\r\n    }\r\n    else if (Array.isArray(filter)) {\r\n        return filter.some(isEqual);\r\n    }\r\n    else if (filter instanceof RegExp) {\r\n        return filter.test(input);\r\n    }\r\n    return false;\r\n}\r\nexport function scoreRoute(route) {\r\n    const [pattern, splat] = route.pattern.split(\"/*\", 2);\r\n    const segments = pattern.split(\"/\").filter(Boolean);\r\n    return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === undefined ? 0 : 1));\r\n}\r\nexport function createMemoObject(fn) {\r\n    const map = new Map();\r\n    const owner = getOwner();\r\n    return new Proxy({}, {\r\n        get(_, property) {\r\n            if (!map.has(property)) {\r\n                runWithOwner(owner, () => map.set(property, createMemo(() => fn()[property])));\r\n            }\r\n            return map.get(property)();\r\n        },\r\n        getOwnPropertyDescriptor() {\r\n            return {\r\n                enumerable: true,\r\n                configurable: true\r\n            };\r\n        },\r\n        ownKeys() {\r\n            return Reflect.ownKeys(fn());\r\n        }\r\n    });\r\n}\r\nexport function mergeSearchString(search, params) {\r\n    const merged = new URLSearchParams(search);\r\n    Object.entries(params).forEach(([key, value]) => {\r\n        if (value == null || value === \"\") {\r\n            merged.delete(key);\r\n        }\r\n        else {\r\n            merged.set(key, String(value));\r\n        }\r\n    });\r\n    const s = merged.toString();\r\n    return s ? `?${s}` : \"\";\r\n}\r\nexport function expandOptionals(pattern) {\r\n    let match = /(\\/?\\:[^\\/]+)\\?/.exec(pattern);\r\n    if (!match)\r\n        return [pattern];\r\n    let prefix = pattern.slice(0, match.index);\r\n    let suffix = pattern.slice(match.index + match[0].length);\r\n    const prefixes = [prefix, (prefix += match[1])];\r\n    // This section handles adjacent optional params. We don't actually want all permuations since\r\n    // that will lead to equivalent routes which have the same number of params. For example\r\n    // `/:a?/:b?/:c`? only has the unique expansion: `/`, `/:a`, `/:a/:b`, `/:a/:b/:c` and we can\r\n    // discard `/:b`, `/:c`, `/:b/:c` by building them up in order and not recursing. This also helps\r\n    // ensure predictability where earlier params have precidence.\r\n    while ((match = /^(\\/\\:[^\\/]+)\\?/.exec(suffix))) {\r\n        prefixes.push((prefix += match[1]));\r\n        suffix = suffix.slice(match[0].length);\r\n    }\r\n    return expandOptionals(suffix).reduce((results, expansion) => [...results, ...prefixes.map(p => p + expansion)], []);\r\n}\r\n",
      "start": 1691669610504,
      "end": 1691669610504
    },
    {
      "name": "vite:define",
      "result": "import { createMemo, getOwner, runWithOwner } from \"solid-js\";\r\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\r\nconst trimPathRegex = /^\\/+|(\\/)\\/+$/g;\r\nexport function normalizePath(path, omitSlash = false) {\r\n    const s = path.replace(trimPathRegex, \"$1\");\r\n    return s ? (omitSlash || /^[?#]/.test(s) ? s : \"/\" + s) : \"\";\r\n}\r\nexport function resolvePath(base, path, from) {\r\n    if (hasSchemeRegex.test(path)) {\r\n        return undefined;\r\n    }\r\n    const basePath = normalizePath(base);\r\n    const fromPath = from && normalizePath(from);\r\n    let result = \"\";\r\n    if (!fromPath || path.startsWith(\"/\")) {\r\n        result = basePath;\r\n    }\r\n    else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\r\n        result = basePath + fromPath;\r\n    }\r\n    else {\r\n        result = fromPath;\r\n    }\r\n    return (result || \"/\") + normalizePath(path, !result);\r\n}\r\nexport function invariant(value, message) {\r\n    if (value == null) {\r\n        throw new Error(message);\r\n    }\r\n    return value;\r\n}\r\nexport function joinPaths(from, to) {\r\n    return normalizePath(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalizePath(to);\r\n}\r\nexport function extractSearchParams(url) {\r\n    const params = {};\r\n    url.searchParams.forEach((value, key) => {\r\n        params[key] = value;\r\n    });\r\n    return params;\r\n}\r\nexport function createMatcher(path, partial, matchFilters) {\r\n    const [pattern, splat] = path.split(\"/*\", 2);\r\n    const segments = pattern.split(\"/\").filter(Boolean);\r\n    const len = segments.length;\r\n    return (location) => {\r\n        const locSegments = location.split(\"/\").filter(Boolean);\r\n        const lenDiff = locSegments.length - len;\r\n        if (lenDiff < 0 || (lenDiff > 0 && splat === undefined && !partial)) {\r\n            return null;\r\n        }\r\n        const match = {\r\n            path: len ? \"\" : \"/\",\r\n            params: {}\r\n        };\r\n        const matchFilter = (s) => matchFilters === undefined ? undefined : matchFilters[s];\r\n        for (let i = 0; i < len; i++) {\r\n            const segment = segments[i];\r\n            const locSegment = locSegments[i];\r\n            const dynamic = segment[0] === \":\";\r\n            const key = dynamic ? segment.slice(1) : segment;\r\n            if (dynamic && matchSegment(locSegment, matchFilter(key))) {\r\n                match.params[key] = locSegment;\r\n            }\r\n            else if (dynamic || !matchSegment(locSegment, segment)) {\r\n                return null;\r\n            }\r\n            match.path += `/${locSegment}`;\r\n        }\r\n        if (splat) {\r\n            const remainder = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\r\n            if (matchSegment(remainder, matchFilter(splat))) {\r\n                match.params[splat] = remainder;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        return match;\r\n    };\r\n}\r\nfunction matchSegment(input, filter) {\r\n    const isEqual = (s) => s.localeCompare(input, undefined, { sensitivity: \"base\" }) === 0;\r\n    if (filter === undefined) {\r\n        return true;\r\n    }\r\n    else if (typeof filter === \"string\") {\r\n        return isEqual(filter);\r\n    }\r\n    else if (typeof filter === \"function\") {\r\n        return filter(input);\r\n    }\r\n    else if (Array.isArray(filter)) {\r\n        return filter.some(isEqual);\r\n    }\r\n    else if (filter instanceof RegExp) {\r\n        return filter.test(input);\r\n    }\r\n    return false;\r\n}\r\nexport function scoreRoute(route) {\r\n    const [pattern, splat] = route.pattern.split(\"/*\", 2);\r\n    const segments = pattern.split(\"/\").filter(Boolean);\r\n    return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === undefined ? 0 : 1));\r\n}\r\nexport function createMemoObject(fn) {\r\n    const map = new Map();\r\n    const owner = getOwner();\r\n    return new Proxy({}, {\r\n        get(_, property) {\r\n            if (!map.has(property)) {\r\n                runWithOwner(owner, () => map.set(property, createMemo(() => fn()[property])));\r\n            }\r\n            return map.get(property)();\r\n        },\r\n        getOwnPropertyDescriptor() {\r\n            return {\r\n                enumerable: true,\r\n                configurable: true\r\n            };\r\n        },\r\n        ownKeys() {\r\n            return Reflect.ownKeys(fn());\r\n        }\r\n    });\r\n}\r\nexport function mergeSearchString(search, params) {\r\n    const merged = new URLSearchParams(search);\r\n    Object.entries(params).forEach(([key, value]) => {\r\n        if (value == null || value === \"\") {\r\n            merged.delete(key);\r\n        }\r\n        else {\r\n            merged.set(key, String(value));\r\n        }\r\n    });\r\n    const s = merged.toString();\r\n    return s ? `?${s}` : \"\";\r\n}\r\nexport function expandOptionals(pattern) {\r\n    let match = /(\\/?\\:[^\\/]+)\\?/.exec(pattern);\r\n    if (!match)\r\n        return [pattern];\r\n    let prefix = pattern.slice(0, match.index);\r\n    let suffix = pattern.slice(match.index + match[0].length);\r\n    const prefixes = [prefix, (prefix += match[1])];\r\n    // This section handles adjacent optional params. We don't actually want all permuations since\r\n    // that will lead to equivalent routes which have the same number of params. For example\r\n    // `/:a?/:b?/:c`? only has the unique expansion: `/`, `/:a`, `/:a/:b`, `/:a/:b/:c` and we can\r\n    // discard `/:b`, `/:c`, `/:b/:c` by building them up in order and not recursing. This also helps\r\n    // ensure predictability where earlier params have precidence.\r\n    while ((match = /^(\\/\\:[^\\/]+)\\?/.exec(suffix))) {\r\n        prefixes.push((prefix += match[1]));\r\n        suffix = suffix.slice(match[0].length);\r\n    }\r\n    return expandOptionals(suffix).reduce((results, expansion) => [...results, ...prefixes.map(p => p + expansion)], []);\r\n}\r\n",
      "start": 1691669610504,
      "end": 1691669610504,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import { createMemo, getOwner, runWithOwner } from \"solid-js\";\r\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\r\nconst trimPathRegex = /^\\/+|(\\/)\\/+$/g;\r\nexport function normalizePath(path, omitSlash = false) {\r\n    const s = path.replace(trimPathRegex, \"$1\");\r\n    return s ? (omitSlash || /^[?#]/.test(s) ? s : \"/\" + s) : \"\";\r\n}\r\nexport function resolvePath(base, path, from) {\r\n    if (hasSchemeRegex.test(path)) {\r\n        return undefined;\r\n    }\r\n    const basePath = normalizePath(base);\r\n    const fromPath = from && normalizePath(from);\r\n    let result = \"\";\r\n    if (!fromPath || path.startsWith(\"/\")) {\r\n        result = basePath;\r\n    }\r\n    else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\r\n        result = basePath + fromPath;\r\n    }\r\n    else {\r\n        result = fromPath;\r\n    }\r\n    return (result || \"/\") + normalizePath(path, !result);\r\n}\r\nexport function invariant(value, message) {\r\n    if (value == null) {\r\n        throw new Error(message);\r\n    }\r\n    return value;\r\n}\r\nexport function joinPaths(from, to) {\r\n    return normalizePath(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalizePath(to);\r\n}\r\nexport function extractSearchParams(url) {\r\n    const params = {};\r\n    url.searchParams.forEach((value, key) => {\r\n        params[key] = value;\r\n    });\r\n    return params;\r\n}\r\nexport function createMatcher(path, partial, matchFilters) {\r\n    const [pattern, splat] = path.split(\"/*\", 2);\r\n    const segments = pattern.split(\"/\").filter(Boolean);\r\n    const len = segments.length;\r\n    return (location) => {\r\n        const locSegments = location.split(\"/\").filter(Boolean);\r\n        const lenDiff = locSegments.length - len;\r\n        if (lenDiff < 0 || (lenDiff > 0 && splat === undefined && !partial)) {\r\n            return null;\r\n        }\r\n        const match = {\r\n            path: len ? \"\" : \"/\",\r\n            params: {}\r\n        };\r\n        const matchFilter = (s) => matchFilters === undefined ? undefined : matchFilters[s];\r\n        for (let i = 0; i < len; i++) {\r\n            const segment = segments[i];\r\n            const locSegment = locSegments[i];\r\n            const dynamic = segment[0] === \":\";\r\n            const key = dynamic ? segment.slice(1) : segment;\r\n            if (dynamic && matchSegment(locSegment, matchFilter(key))) {\r\n                match.params[key] = locSegment;\r\n            }\r\n            else if (dynamic || !matchSegment(locSegment, segment)) {\r\n                return null;\r\n            }\r\n            match.path += `/${locSegment}`;\r\n        }\r\n        if (splat) {\r\n            const remainder = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\r\n            if (matchSegment(remainder, matchFilter(splat))) {\r\n                match.params[splat] = remainder;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        return match;\r\n    };\r\n}\r\nfunction matchSegment(input, filter) {\r\n    const isEqual = (s) => s.localeCompare(input, undefined, { sensitivity: \"base\" }) === 0;\r\n    if (filter === undefined) {\r\n        return true;\r\n    }\r\n    else if (typeof filter === \"string\") {\r\n        return isEqual(filter);\r\n    }\r\n    else if (typeof filter === \"function\") {\r\n        return filter(input);\r\n    }\r\n    else if (Array.isArray(filter)) {\r\n        return filter.some(isEqual);\r\n    }\r\n    else if (filter instanceof RegExp) {\r\n        return filter.test(input);\r\n    }\r\n    return false;\r\n}\r\nexport function scoreRoute(route) {\r\n    const [pattern, splat] = route.pattern.split(\"/*\", 2);\r\n    const segments = pattern.split(\"/\").filter(Boolean);\r\n    return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === undefined ? 0 : 1));\r\n}\r\nexport function createMemoObject(fn) {\r\n    const map = new Map();\r\n    const owner = getOwner();\r\n    return new Proxy({}, {\r\n        get(_, property) {\r\n            if (!map.has(property)) {\r\n                runWithOwner(owner, () => map.set(property, createMemo(() => fn()[property])));\r\n            }\r\n            return map.get(property)();\r\n        },\r\n        getOwnPropertyDescriptor() {\r\n            return {\r\n                enumerable: true,\r\n                configurable: true\r\n            };\r\n        },\r\n        ownKeys() {\r\n            return Reflect.ownKeys(fn());\r\n        }\r\n    });\r\n}\r\nexport function mergeSearchString(search, params) {\r\n    const merged = new URLSearchParams(search);\r\n    Object.entries(params).forEach(([key, value]) => {\r\n        if (value == null || value === \"\") {\r\n            merged.delete(key);\r\n        }\r\n        else {\r\n            merged.set(key, String(value));\r\n        }\r\n    });\r\n    const s = merged.toString();\r\n    return s ? `?${s}` : \"\";\r\n}\r\nexport function expandOptionals(pattern) {\r\n    let match = /(\\/?\\:[^\\/]+)\\?/.exec(pattern);\r\n    if (!match)\r\n        return [pattern];\r\n    let prefix = pattern.slice(0, match.index);\r\n    let suffix = pattern.slice(match.index + match[0].length);\r\n    const prefixes = [prefix, (prefix += match[1])];\r\n    // This section handles adjacent optional params. We don't actually want all permuations since\r\n    // that will lead to equivalent routes which have the same number of params. For example\r\n    // `/:a?/:b?/:c`? only has the unique expansion: `/`, `/:a`, `/:a/:b`, `/:a/:b/:c` and we can\r\n    // discard `/:b`, `/:c`, `/:b/:c` by building them up in order and not recursing. This also helps\r\n    // ensure predictability where earlier params have precidence.\r\n    while ((match = /^(\\/\\:[^\\/]+)\\?/.exec(suffix))) {\r\n        prefixes.push((prefix += match[1]));\r\n        suffix = suffix.slice(match[0].length);\r\n    }\r\n    return expandOptionals(suffix).reduce((results, expansion) => [...results, ...prefixes.map(p => p + expansion)], []);\r\n}\r\n",
      "start": 1691669610504,
      "end": 1691669610505,
      "order": "normal"
    }
  ]
}
