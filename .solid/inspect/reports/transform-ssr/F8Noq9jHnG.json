{
  "resolvedId": "C:/solid js/authentication-client/node_modules/@solidjs/router/dist/components.jsx",
  "transforms": [
    {
      "name": "__load__",
      "result": "/*@refresh skip*/\r\nimport { children, createMemo, createRoot, mergeProps, on, Show, splitProps } from \"solid-js\";\r\nimport { isServer } from \"solid-js/web\";\r\nimport { pathIntegration, staticIntegration } from \"./integration\";\r\nimport { createBranches, createRouteContext, createRouterContext, getRouteMatches, RouteContextObj, RouterContextObj, useHref, useLocation, useNavigate, useResolvedPath, useRoute, useRouter } from \"./routing\";\r\nimport { joinPaths, normalizePath, createMemoObject } from \"./utils\";\r\nexport const Router = (props) => {\r\n    const { source, url, base, data, out } = props;\r\n    const integration = source || (isServer ? staticIntegration({ value: url || \"\" }) : pathIntegration());\r\n    const routerState = createRouterContext(integration, base, data, out);\r\n    return (<RouterContextObj.Provider value={routerState}>{props.children}</RouterContextObj.Provider>);\r\n};\r\nexport const Routes = (props) => {\r\n    const router = useRouter();\r\n    const parentRoute = useRoute();\r\n    const routeDefs = children(() => props.children);\r\n    const branches = createMemo(() => createBranches(routeDefs(), joinPaths(parentRoute.pattern, props.base || \"\"), Outlet));\r\n    const matches = createMemo(() => getRouteMatches(branches(), router.location.pathname));\r\n    const params = createMemoObject(() => {\r\n        const m = matches();\r\n        const params = {};\r\n        for (let i = 0; i < m.length; i++) {\r\n            Object.assign(params, m[i].params);\r\n        }\r\n        return params;\r\n    });\r\n    if (router.out) {\r\n        router.out.matches.push(matches().map(({ route, path, params }) => ({\r\n            originalPath: route.originalPath,\r\n            pattern: route.pattern,\r\n            path,\r\n            params\r\n        })));\r\n    }\r\n    const disposers = [];\r\n    let root;\r\n    const routeStates = createMemo(on(matches, (nextMatches, prevMatches, prev) => {\r\n        let equal = prevMatches && nextMatches.length === prevMatches.length;\r\n        const next = [];\r\n        for (let i = 0, len = nextMatches.length; i < len; i++) {\r\n            const prevMatch = prevMatches && prevMatches[i];\r\n            const nextMatch = nextMatches[i];\r\n            if (prev && prevMatch && nextMatch.route.key === prevMatch.route.key) {\r\n                next[i] = prev[i];\r\n            }\r\n            else {\r\n                equal = false;\r\n                if (disposers[i]) {\r\n                    disposers[i]();\r\n                }\r\n                createRoot(dispose => {\r\n                    disposers[i] = dispose;\r\n                    next[i] = createRouteContext(router, next[i - 1] || parentRoute, () => routeStates()[i + 1], () => matches()[i], params);\r\n                });\r\n            }\r\n        }\r\n        disposers.splice(nextMatches.length).forEach(dispose => dispose());\r\n        if (prev && equal) {\r\n            return prev;\r\n        }\r\n        root = next[0];\r\n        return next;\r\n    }));\r\n    return (<Show when={routeStates() && root} keyed>\r\n      {route => <RouteContextObj.Provider value={route}>{route.outlet()}</RouteContextObj.Provider>}\r\n    </Show>);\r\n};\r\nexport const useRoutes = (routes, base) => {\r\n    return () => <Routes base={base}>{routes}</Routes>;\r\n};\r\nexport const Route = (props) => {\r\n    const childRoutes = children(() => props.children);\r\n    return mergeProps(props, {\r\n        get children() {\r\n            return childRoutes();\r\n        }\r\n    });\r\n};\r\nexport const Outlet = () => {\r\n    const route = useRoute();\r\n    return (<Show when={route.child} keyed>\r\n      {child => <RouteContextObj.Provider value={child}>{child.outlet()}</RouteContextObj.Provider>}\r\n    </Show>);\r\n};\r\nexport function A(props) {\r\n    props = mergeProps({ inactiveClass: \"inactive\", activeClass: \"active\" }, props);\r\n    const [, rest] = splitProps(props, [\r\n        \"href\",\r\n        \"state\",\r\n        \"class\",\r\n        \"activeClass\",\r\n        \"inactiveClass\",\r\n        \"end\"\r\n    ]);\r\n    const to = useResolvedPath(() => props.href);\r\n    const href = useHref(to);\r\n    const location = useLocation();\r\n    const isActive = createMemo(() => {\r\n        const to_ = to();\r\n        if (to_ === undefined)\r\n            return false;\r\n        const path = normalizePath(to_.split(/[?#]/, 1)[0]).toLowerCase();\r\n        const loc = normalizePath(location.pathname).toLowerCase();\r\n        return props.end ? path === loc : loc.startsWith(path);\r\n    });\r\n    return (<a link {...rest} href={href() || props.href} state={JSON.stringify(props.state)} classList={{\r\n            ...(props.class && { [props.class]: true }),\r\n            [props.inactiveClass]: !isActive(),\r\n            [props.activeClass]: isActive(),\r\n            ...rest.classList\r\n        }} aria-current={isActive() ? \"page\" : undefined}/>);\r\n}\r\n// deprecated alias exports\r\nexport { A as Link, A as NavLink };\r\nexport function Navigate(props) {\r\n    const navigate = useNavigate();\r\n    const location = useLocation();\r\n    const { href, state } = props;\r\n    const path = typeof href === \"function\" ? href({ navigate, location }) : href;\r\n    navigate(path, { replace: true, state });\r\n    return null;\r\n}\r\n",
      "start": 1691669610450,
      "end": 1691669610450
    },
    {
      "name": "solid",
      "result": "import { ssrElement as _$ssrElement } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { createComponent as _$createComponent } from \"solid-js/web\";\n/*@refresh skip*/\nimport { children, createMemo, createRoot, mergeProps, on, Show, splitProps } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\nimport { pathIntegration, staticIntegration } from \"./integration\";\nimport { createBranches, createRouteContext, createRouterContext, getRouteMatches, RouteContextObj, RouterContextObj, useHref, useLocation, useNavigate, useResolvedPath, useRoute, useRouter } from \"./routing\";\nimport { joinPaths, normalizePath, createMemoObject } from \"./utils\";\nexport const Router = props => {\n  const {\n    source,\n    url,\n    base,\n    data,\n    out\n  } = props;\n  const integration = source || (isServer ? staticIntegration({\n    value: url || \"\"\n  }) : pathIntegration());\n  const routerState = createRouterContext(integration, base, data, out);\n  return _$createComponent(RouterContextObj.Provider, {\n    value: routerState,\n    get children() {\n      return props.children;\n    }\n  });\n};\nexport const Routes = props => {\n  const router = useRouter();\n  const parentRoute = useRoute();\n  const routeDefs = children(() => props.children);\n  const branches = createMemo(() => createBranches(routeDefs(), joinPaths(parentRoute.pattern, props.base || \"\"), Outlet));\n  const matches = createMemo(() => getRouteMatches(branches(), router.location.pathname));\n  const params = createMemoObject(() => {\n    const m = matches();\n    const params = {};\n    for (let i = 0; i < m.length; i++) {\n      Object.assign(params, m[i].params);\n    }\n    return params;\n  });\n  if (router.out) {\n    router.out.matches.push(matches().map(({\n      route,\n      path,\n      params\n    }) => ({\n      originalPath: route.originalPath,\n      pattern: route.pattern,\n      path,\n      params\n    })));\n  }\n  const disposers = [];\n  let root;\n  const routeStates = createMemo(on(matches, (nextMatches, prevMatches, prev) => {\n    let equal = prevMatches && nextMatches.length === prevMatches.length;\n    const next = [];\n    for (let i = 0, len = nextMatches.length; i < len; i++) {\n      const prevMatch = prevMatches && prevMatches[i];\n      const nextMatch = nextMatches[i];\n      if (prev && prevMatch && nextMatch.route.key === prevMatch.route.key) {\n        next[i] = prev[i];\n      } else {\n        equal = false;\n        if (disposers[i]) {\n          disposers[i]();\n        }\n        createRoot(dispose => {\n          disposers[i] = dispose;\n          next[i] = createRouteContext(router, next[i - 1] || parentRoute, () => routeStates()[i + 1], () => matches()[i], params);\n        });\n      }\n    }\n    disposers.splice(nextMatches.length).forEach(dispose => dispose());\n    if (prev && equal) {\n      return prev;\n    }\n    root = next[0];\n    return next;\n  }));\n  return _$createComponent(Show, {\n    get when() {\n      return routeStates() && root;\n    },\n    keyed: true,\n    children: route => _$createComponent(RouteContextObj.Provider, {\n      value: route,\n      get children() {\n        return route.outlet();\n      }\n    })\n  });\n};\nexport const useRoutes = (routes, base) => {\n  return () => _$createComponent(Routes, {\n    base: base,\n    children: routes\n  });\n};\nexport const Route = props => {\n  const childRoutes = children(() => props.children);\n  return mergeProps(props, {\n    get children() {\n      return childRoutes();\n    }\n  });\n};\nexport const Outlet = () => {\n  const route = useRoute();\n  return _$createComponent(Show, {\n    get when() {\n      return route.child;\n    },\n    keyed: true,\n    children: child => _$createComponent(RouteContextObj.Provider, {\n      value: child,\n      get children() {\n        return child.outlet();\n      }\n    })\n  });\n};\nexport function A(props) {\n  props = mergeProps({\n    inactiveClass: \"inactive\",\n    activeClass: \"active\"\n  }, props);\n  const [, rest] = splitProps(props, [\"href\", \"state\", \"class\", \"activeClass\", \"inactiveClass\", \"end\"]);\n  const to = useResolvedPath(() => props.href);\n  const href = useHref(to);\n  const location = useLocation();\n  const isActive = createMemo(() => {\n    const to_ = to();\n    if (to_ === undefined) return false;\n    const path = normalizePath(to_.split(/[?#]/, 1)[0]).toLowerCase();\n    const loc = normalizePath(location.pathname).toLowerCase();\n    return props.end ? path === loc : loc.startsWith(path);\n  });\n  return _$ssrElement(\"a\", _$mergeProps({\n    link: true\n  }, rest, {\n    get href() {\n      return href() || props.href;\n    },\n    get state() {\n      return JSON.stringify(props.state);\n    },\n    get classList() {\n      return {\n        ...(props.class && {\n          [props.class]: true\n        }),\n        [props.inactiveClass]: !isActive(),\n        [props.activeClass]: isActive(),\n        ...rest.classList\n      };\n    },\n    get [\"aria-current\"]() {\n      return isActive() ? \"page\" : undefined;\n    }\n  }), undefined, true);\n}\n// deprecated alias exports\nexport { A as Link, A as NavLink };\nexport function Navigate(props) {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const {\n    href,\n    state\n  } = props;\n  const path = typeof href === \"function\" ? href({\n    navigate,\n    location\n  }) : href;\n  navigate(path, {\n    replace: true,\n    state\n  });\n  return null;\n}",
      "start": 1691669610450,
      "end": 1691669610477,
      "order": "pre"
    },
    {
      "name": "vite:define",
      "result": "import { ssrElement as _$ssrElement } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { createComponent as _$createComponent } from \"solid-js/web\";\n/*@refresh skip*/\nimport { children, createMemo, createRoot, mergeProps, on, Show, splitProps } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\nimport { pathIntegration, staticIntegration } from \"./integration\";\nimport { createBranches, createRouteContext, createRouterContext, getRouteMatches, RouteContextObj, RouterContextObj, useHref, useLocation, useNavigate, useResolvedPath, useRoute, useRouter } from \"./routing\";\nimport { joinPaths, normalizePath, createMemoObject } from \"./utils\";\nexport const Router = props => {\n  const {\n    source,\n    url,\n    base,\n    data,\n    out\n  } = props;\n  const integration = source || (isServer ? staticIntegration({\n    value: url || \"\"\n  }) : pathIntegration());\n  const routerState = createRouterContext(integration, base, data, out);\n  return _$createComponent(RouterContextObj.Provider, {\n    value: routerState,\n    get children() {\n      return props.children;\n    }\n  });\n};\nexport const Routes = props => {\n  const router = useRouter();\n  const parentRoute = useRoute();\n  const routeDefs = children(() => props.children);\n  const branches = createMemo(() => createBranches(routeDefs(), joinPaths(parentRoute.pattern, props.base || \"\"), Outlet));\n  const matches = createMemo(() => getRouteMatches(branches(), router.location.pathname));\n  const params = createMemoObject(() => {\n    const m = matches();\n    const params = {};\n    for (let i = 0; i < m.length; i++) {\n      Object.assign(params, m[i].params);\n    }\n    return params;\n  });\n  if (router.out) {\n    router.out.matches.push(matches().map(({\n      route,\n      path,\n      params\n    }) => ({\n      originalPath: route.originalPath,\n      pattern: route.pattern,\n      path,\n      params\n    })));\n  }\n  const disposers = [];\n  let root;\n  const routeStates = createMemo(on(matches, (nextMatches, prevMatches, prev) => {\n    let equal = prevMatches && nextMatches.length === prevMatches.length;\n    const next = [];\n    for (let i = 0, len = nextMatches.length; i < len; i++) {\n      const prevMatch = prevMatches && prevMatches[i];\n      const nextMatch = nextMatches[i];\n      if (prev && prevMatch && nextMatch.route.key === prevMatch.route.key) {\n        next[i] = prev[i];\n      } else {\n        equal = false;\n        if (disposers[i]) {\n          disposers[i]();\n        }\n        createRoot(dispose => {\n          disposers[i] = dispose;\n          next[i] = createRouteContext(router, next[i - 1] || parentRoute, () => routeStates()[i + 1], () => matches()[i], params);\n        });\n      }\n    }\n    disposers.splice(nextMatches.length).forEach(dispose => dispose());\n    if (prev && equal) {\n      return prev;\n    }\n    root = next[0];\n    return next;\n  }));\n  return _$createComponent(Show, {\n    get when() {\n      return routeStates() && root;\n    },\n    keyed: true,\n    children: route => _$createComponent(RouteContextObj.Provider, {\n      value: route,\n      get children() {\n        return route.outlet();\n      }\n    })\n  });\n};\nexport const useRoutes = (routes, base) => {\n  return () => _$createComponent(Routes, {\n    base: base,\n    children: routes\n  });\n};\nexport const Route = props => {\n  const childRoutes = children(() => props.children);\n  return mergeProps(props, {\n    get children() {\n      return childRoutes();\n    }\n  });\n};\nexport const Outlet = () => {\n  const route = useRoute();\n  return _$createComponent(Show, {\n    get when() {\n      return route.child;\n    },\n    keyed: true,\n    children: child => _$createComponent(RouteContextObj.Provider, {\n      value: child,\n      get children() {\n        return child.outlet();\n      }\n    })\n  });\n};\nexport function A(props) {\n  props = mergeProps({\n    inactiveClass: \"inactive\",\n    activeClass: \"active\"\n  }, props);\n  const [, rest] = splitProps(props, [\"href\", \"state\", \"class\", \"activeClass\", \"inactiveClass\", \"end\"]);\n  const to = useResolvedPath(() => props.href);\n  const href = useHref(to);\n  const location = useLocation();\n  const isActive = createMemo(() => {\n    const to_ = to();\n    if (to_ === undefined) return false;\n    const path = normalizePath(to_.split(/[?#]/, 1)[0]).toLowerCase();\n    const loc = normalizePath(location.pathname).toLowerCase();\n    return props.end ? path === loc : loc.startsWith(path);\n  });\n  return _$ssrElement(\"a\", _$mergeProps({\n    link: true\n  }, rest, {\n    get href() {\n      return href() || props.href;\n    },\n    get state() {\n      return JSON.stringify(props.state);\n    },\n    get classList() {\n      return {\n        ...(props.class && {\n          [props.class]: true\n        }),\n        [props.inactiveClass]: !isActive(),\n        [props.activeClass]: isActive(),\n        ...rest.classList\n      };\n    },\n    get [\"aria-current\"]() {\n      return isActive() ? \"page\" : undefined;\n    }\n  }), undefined, true);\n}\n// deprecated alias exports\nexport { A as Link, A as NavLink };\nexport function Navigate(props) {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const {\n    href,\n    state\n  } = props;\n  const path = typeof href === \"function\" ? href({\n    navigate,\n    location\n  }) : href;\n  navigate(path, {\n    replace: true,\n    state\n  });\n  return null;\n}",
      "start": 1691669610477,
      "end": 1691669610477,
      "order": "normal"
    },
    {
      "name": "vite:import-analysis",
      "result": "import { ssrElement as _$ssrElement } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { createComponent as _$createComponent } from \"solid-js/web\";\n/*@refresh skip*/\nimport { children, createMemo, createRoot, mergeProps, on, Show, splitProps } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\nimport { pathIntegration, staticIntegration } from \"/node_modules/@solidjs/router/dist/integration.js\";\nimport { createBranches, createRouteContext, createRouterContext, getRouteMatches, RouteContextObj, RouterContextObj, useHref, useLocation, useNavigate, useResolvedPath, useRoute, useRouter } from \"/node_modules/@solidjs/router/dist/routing.js\";\nimport { joinPaths, normalizePath, createMemoObject } from \"/node_modules/@solidjs/router/dist/utils.js\";\nexport const Router = props => {\n  const {\n    source,\n    url,\n    base,\n    data,\n    out\n  } = props;\n  const integration = source || (isServer ? staticIntegration({\n    value: url || \"\"\n  }) : pathIntegration());\n  const routerState = createRouterContext(integration, base, data, out);\n  return _$createComponent(RouterContextObj.Provider, {\n    value: routerState,\n    get children() {\n      return props.children;\n    }\n  });\n};\nexport const Routes = props => {\n  const router = useRouter();\n  const parentRoute = useRoute();\n  const routeDefs = children(() => props.children);\n  const branches = createMemo(() => createBranches(routeDefs(), joinPaths(parentRoute.pattern, props.base || \"\"), Outlet));\n  const matches = createMemo(() => getRouteMatches(branches(), router.location.pathname));\n  const params = createMemoObject(() => {\n    const m = matches();\n    const params = {};\n    for (let i = 0; i < m.length; i++) {\n      Object.assign(params, m[i].params);\n    }\n    return params;\n  });\n  if (router.out) {\n    router.out.matches.push(matches().map(({\n      route,\n      path,\n      params\n    }) => ({\n      originalPath: route.originalPath,\n      pattern: route.pattern,\n      path,\n      params\n    })));\n  }\n  const disposers = [];\n  let root;\n  const routeStates = createMemo(on(matches, (nextMatches, prevMatches, prev) => {\n    let equal = prevMatches && nextMatches.length === prevMatches.length;\n    const next = [];\n    for (let i = 0, len = nextMatches.length; i < len; i++) {\n      const prevMatch = prevMatches && prevMatches[i];\n      const nextMatch = nextMatches[i];\n      if (prev && prevMatch && nextMatch.route.key === prevMatch.route.key) {\n        next[i] = prev[i];\n      } else {\n        equal = false;\n        if (disposers[i]) {\n          disposers[i]();\n        }\n        createRoot(dispose => {\n          disposers[i] = dispose;\n          next[i] = createRouteContext(router, next[i - 1] || parentRoute, () => routeStates()[i + 1], () => matches()[i], params);\n        });\n      }\n    }\n    disposers.splice(nextMatches.length).forEach(dispose => dispose());\n    if (prev && equal) {\n      return prev;\n    }\n    root = next[0];\n    return next;\n  }));\n  return _$createComponent(Show, {\n    get when() {\n      return routeStates() && root;\n    },\n    keyed: true,\n    children: route => _$createComponent(RouteContextObj.Provider, {\n      value: route,\n      get children() {\n        return route.outlet();\n      }\n    })\n  });\n};\nexport const useRoutes = (routes, base) => {\n  return () => _$createComponent(Routes, {\n    base: base,\n    children: routes\n  });\n};\nexport const Route = props => {\n  const childRoutes = children(() => props.children);\n  return mergeProps(props, {\n    get children() {\n      return childRoutes();\n    }\n  });\n};\nexport const Outlet = () => {\n  const route = useRoute();\n  return _$createComponent(Show, {\n    get when() {\n      return route.child;\n    },\n    keyed: true,\n    children: child => _$createComponent(RouteContextObj.Provider, {\n      value: child,\n      get children() {\n        return child.outlet();\n      }\n    })\n  });\n};\nexport function A(props) {\n  props = mergeProps({\n    inactiveClass: \"inactive\",\n    activeClass: \"active\"\n  }, props);\n  const [, rest] = splitProps(props, [\"href\", \"state\", \"class\", \"activeClass\", \"inactiveClass\", \"end\"]);\n  const to = useResolvedPath(() => props.href);\n  const href = useHref(to);\n  const location = useLocation();\n  const isActive = createMemo(() => {\n    const to_ = to();\n    if (to_ === undefined) return false;\n    const path = normalizePath(to_.split(/[?#]/, 1)[0]).toLowerCase();\n    const loc = normalizePath(location.pathname).toLowerCase();\n    return props.end ? path === loc : loc.startsWith(path);\n  });\n  return _$ssrElement(\"a\", _$mergeProps({\n    link: true\n  }, rest, {\n    get href() {\n      return href() || props.href;\n    },\n    get state() {\n      return JSON.stringify(props.state);\n    },\n    get classList() {\n      return {\n        ...(props.class && {\n          [props.class]: true\n        }),\n        [props.inactiveClass]: !isActive(),\n        [props.activeClass]: isActive(),\n        ...rest.classList\n      };\n    },\n    get [\"aria-current\"]() {\n      return isActive() ? \"page\" : undefined;\n    }\n  }), undefined, true);\n}\n// deprecated alias exports\nexport { A as Link, A as NavLink };\nexport function Navigate(props) {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const {\n    href,\n    state\n  } = props;\n  const path = typeof href === \"function\" ? href({\n    navigate,\n    location\n  }) : href;\n  navigate(path, {\n    replace: true,\n    state\n  });\n  return null;\n}",
      "start": 1691669610477,
      "end": 1691669610478,
      "order": "normal"
    }
  ]
}
